<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Index â€” Search</title>
  <link href="resources/styles/serp.css" rel="stylesheet">
  <link href="resources/styles/universal.css" rel="stylesheet">
</head>

<body>
  <header id="hdr" class="hdr" style="--hdr-h:72px">
    <div class="hdr-inner">
      <div class="bar">
        <a href="/" aria-label="Index home">
          <img class="logo-img" src="resources/service-icons/mini-mini.png" alt="Index">
        </a>

        <div class="search-table">
          <form class="search" id="searchForm" autocomplete="off">
            <input class="q" id="q" name="q" type="search" placeholder="Search the index" autofocus />
            <div id="suggestions" class="suggestions-list" aria-label="Suggestions"></div>
          </form>
          <button id="goBtn" class="bar-search-button" type="button">Go</button>
        </div>

        <div style="display:flex; gap:8px;">
          <button id="filtersBtn" class="icon-btn" aria-label="Filters">
            <img class="icon" src="resources/svg/tune_24dp_E3E3E3_FILL0_wght400_GRAD0_opsz24.svg">
          </button>
          <button id="fastlaneBtn" class="icon-btn" aria-label="Fastlane">
            <img class="icon" src="resources/svg/dashboard_24dp_E3E3E3_FILL0_wght400_GRAD0_opsz24.svg">
          </button>
        </div>
      </div>

      <div id="filtersRow" class="filters hidden" aria-hidden="true">
        <!-- Dynamic filters will be rendered here -->
      </div>

      <div id="fastlane" class="fastlane" aria-hidden="true">
        <div class="fl-grid">
          <div class="fl-item">
            <div class="ico"></div><span>Web</span>
          </div>
          <div class="fl-item">
            <div class="ico"></div><span>Images</span>
          </div>
          <div class="fl-item">
            <div class="ico"></div><span>Video</span>
          </div>
          <div class="fl-item">
            <div class="ico"></div><span>Maps</span>
          </div>
          <div class="fl-item">
            <div class="ico"></div><span>News</span>
          </div>
          <div class="fl-item">
            <div class="ico"></div><span>Translate</span>
          </div>
          <div class="fl-item">
            <div class="ico"></div><span>Mail</span>
          </div>
          <div class="fl-item">
            <div class="ico"></div><span>Docs</span>
          </div>
          <div class="fl-item">
            <div class="ico"></div><span>Settings</span>
          </div>
          <div class="fl-item">
            <div class="ico"></div><span>Profile</span>
          </div>
          <div class="fl-item">
            <div class="ico"></div><span>Shortcuts</span>
          </div>
          <div class="fl-item">
            <div class="ico"></div><span>Labs</span>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main class="page">
    <!-- Sidebar: dynamically filled with methods -->
    <nav id="typesNav" class="types" aria-label="Search types">
      <!-- Methods will be rendered here -->
    </nav>

    <!-- Main column: dynamic islands + results -->
    <section id="main" class="main" aria-label="Main results">
      <div id="mainIslands"></div>
      <div id="results"></div>
      <div id="pager" class="pager" style="display:none;"></div>
    </section>

    <!-- Misc/supporting islands -->
    <aside id="supportingIslands" class="aside" aria-label="Related">
      <!-- Supporting islands will be rendered here -->
    </aside>
  </main>

  <script>
    // Header toggle logic (kept)
    const hdr = document.getElementById('hdr');
    const filtersBtn = document.getElementById('filtersBtn');
    const fastlaneBtn = document.getElementById('fastlaneBtn');
    const filtersRow = document.getElementById('filtersRow');
    const fastlane = document.getElementById('fastlane');
    let filtersOpen = false;
    let fastlaneOpen = false;

    function applyHeaderState() {
      hdr.classList.toggle('is-filters', filtersOpen);
      hdr.classList.toggle('is-fastlane', fastlaneOpen);
      filtersRow.classList.toggle('hidden', !filtersOpen);
      filtersRow.setAttribute('aria-hidden', String(!filtersOpen));
      fastlane.classList.toggle('open', fastlaneOpen);
      fastlane.setAttribute('aria-hidden', String(!fastlaneOpen));
    }

    filtersBtn.addEventListener('click', () => {
      filtersOpen = !filtersOpen;
      applyHeaderState();
    });

    fastlaneBtn.addEventListener('click', () => {
      fastlaneOpen = !fastlaneOpen;
      applyHeaderState();
    });

    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && (fastlaneOpen || filtersOpen)) {
        fastlaneOpen = false; filtersOpen = false; applyHeaderState();
      }
    });

    // ----------------- Old frontend logic ported -----------------
    const url = new URL(window.location.href);
    const NODE = url.searchParams.get('node') || 'http://localhost:3000';

    let methods = [];
    let selectedMethod = null;
    let methodCapabilities = {};
    let currentPage = 1;
    let filterValues = {};

    const typesNav = document.getElementById('typesNav');
    const resultsDiv = document.getElementById('results');
    const mainIslandsDiv = document.getElementById('mainIslands');
    const supportingIslands = document.getElementById('supportingIslands');
    const pagerDiv = document.getElementById('pager');
    const searchForm = document.getElementById('searchForm');
    const qInput = document.getElementById('q');
    const goBtn = document.getElementById('goBtn');
    const suggestionsDiv = document.getElementById('suggestions');
// Portal the suggestions out of header to avoid clipping
document.body.appendChild(suggestionsDiv);
Object.assign(suggestionsDiv.style, {
  position: 'fixed',
  left: '0px',
  top: '0px',
  right: 'auto',
  display: 'none',
  zIndex: '9999'
});

const SUGG_MARGIN = 6;
let suggItems = [];
let suggIdx = -1;

function layoutSuggestions() {
  if (suggestionsDiv.style.display !== 'block') return;
  const r = qInput.getBoundingClientRect();
  if (!r.width || !r.height) return;

  // Default below input
  const belowTop = r.bottom + SUGG_MARGIN;
  const maxBelow = window.innerHeight - belowTop - 8;

  // Temporarily show to calculate intrinsic height
  const prevDisplay = suggestionsDiv.style.display;
  suggestionsDiv.style.display = 'block';
  const intrinsic = Math.min(240, suggestionsDiv.scrollHeight || 240);
  suggestionsDiv.style.display = prevDisplay;

  // If not enough room below, place above
  const placeAbove = maxBelow < Math.min(intrinsic, 180);
  const top = placeAbove
    ? Math.max(8, r.top - SUGG_MARGIN - Math.min(240, r.top - 8))
    : belowTop;

  suggestionsDiv.style.left = `${Math.round(r.left)}px`;
  suggestionsDiv.style.top = `${Math.round(top)}px`;
  suggestionsDiv.style.width = `${Math.round(r.width)}px`;
  suggestionsDiv.style.maxHeight = `${placeAbove ? Math.min(240, r.top - 8) : Math.min(240, maxBelow)}px`;
}

function showSuggestions(list) {
  suggestionsDiv.innerHTML = '';
  suggItems = list || [];
  suggIdx = -1;

  if (!suggItems.length) {
    suggestionsDiv.style.display = 'none';
    return;
  }

  for (let i = 0; i < suggItems.length; i++) {
    const s = suggItems[i];
    const item = document.createElement('div');
    item.className = 'suggestion-item';
    item.textContent = s;
    item.onclick = () => {
      qInput.value = s;
      suggestionsDiv.style.display = 'none';
      qInput.focus();
      // handleSearch(); // optional
    };
    suggestionsDiv.appendChild(item);
  }

  suggestionsDiv.style.display = 'block';
  layoutSuggestions();
}

// Keyboard navigation
qInput.addEventListener('keydown', (e) => {
  if (suggestionsDiv.style.display !== 'block' || !suggItems.length) return;

  if (e.key === 'ArrowDown') {
    suggIdx = (suggIdx + 1) % suggItems.length;
    [...suggestionsDiv.children].forEach((n, i) => n.classList.toggle('selected', i === suggIdx));
    e.preventDefault();
  } else if (e.key === 'ArrowUp') {
    suggIdx = (suggIdx - 1 + suggItems.length) % suggItems.length;
    [...suggestionsDiv.children].forEach((n, i) => n.classList.toggle('selected', i === suggIdx));
    e.preventDefault();
  } else if (e.key === 'Enter') {
    if (suggIdx >= 0 && suggIdx < suggItems.length) {
      qInput.value = suggItems[suggIdx];
      suggestionsDiv.style.display = 'none';
      e.preventDefault();
    }
  } else if (e.key === 'Escape') {
    suggestionsDiv.style.display = 'none';
  }
});

// Fetch + debounce
let debounceId = null;
let lastFetchId = 0;

async function fetchSuggestions(query) {
  if (!query) return [];
  try {
    const res = await fetch(NODE + '/suggest', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ partial: query })
    });
    if (!res.ok) return [];
    const data = await res.json();
    return Array.isArray(data.suggestions) ? data.suggestions : [];
  } catch {
    return [];
  }
}

qInput.addEventListener('input', () => {
  const val = qInput.value.trim();
  if (debounceId) clearTimeout(debounceId);

  if (!val) {
    suggestionsDiv.style.display = 'none';
    return;
  }

  const fetchId = ++lastFetchId;
  debounceId = setTimeout(async () => {
    const list = await fetchSuggestions(val);
    if (fetchId !== lastFetchId) return;
    showSuggestions(list);
  }, 180);
});

// Close on outside click
document.addEventListener('click', (e) => {
  if (!suggestionsDiv.contains(e.target) && e.target !== qInput) {
    suggestionsDiv.style.display = 'none';
  }
});

// Keep aligned during layout changes
const relayout = () => layoutSuggestions();
window.addEventListener('resize', relayout, { passive: true });
// Capture-phase scroll hits any scrollable ancestor
window.addEventListener('scroll', relayout, { passive: true, capture: true });
qInput.addEventListener('focus', relayout);

// Reflow when returning to tab or page is shown from bfcache
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') relayout();
});
window.addEventListener('pageshow', relayout);

// If you have a header toggle (filters/fastlane), re-run layout after it changes
const _applyHeaderState = applyHeaderState;
applyHeaderState = function () {
  _applyHeaderState();
  relayout();
};

// Optional: track direct size changes of the input (font zoom, container resize)
if ('ResizeObserver' in window) {
  const ro = new ResizeObserver(() => relayout());
  ro.observe(qInput);
}
function prettifyId(id) {
  return id
    .replace(/[-_]+/g, ' ')            // kebab/underscore to spaces
    .replace(/([a-z0-9])([A-Z])/g, '$1 $2') // split camelCase
    .replace(/\s+/g, ' ')
    .trim()
    .replace(/\b\w/g, c => c.toUpperCase()); // Title Case
}

function getMethodLabel(id) {
  const caps = methodCapabilities[id] || {};
  return caps.displayName || caps.label || caps.name || caps.title || prettifyId(id);
}

function getMethodDescription(id) {
  const caps = methodCapabilities[id] || {};
  return caps.description || '';
}

    function getParam(name) {
      return url.searchParams.get(name);
    }

    async function fetchMethods() {
      try {
        const res = await fetch(NODE + '/metadata');
        const data = await res.json();
        methods = data.methods || [];
        methodCapabilities = data.methodCapabilities || {};
        renderMethods();

        // Select method from URL ?method= or ?type=
        const urlMethod = getParam('method') || getParam('type');
        if (!selectedMethod && methods.length) {
          const pick = methods.includes(urlMethod) ? urlMethod : methods[0];
          selectMethod(pick);
        }

        // Pre-fill query
        const q = getParam('q');
        if (q) {
          qInput.value = q;
          // Optional: auto search when query exists
          handleSearch();
        }
      } catch (e) {
        console.error('Failed to fetch methods:', e);
      }
    }

    function renderMethods() {
        if (!typesNav) return;
        typesNav.innerHTML = '';
        methods.forEach((method) => {
            const label = getMethodLabel(method);
            const desc = getMethodDescription(method);
            const a = document.createElement('a');
            a.className = 'type';
            if (method === selectedMethod) a.setAttribute('aria-current', 'page');
            a.href = '#';
            a.title = desc || label; // nice hover text if you have description
            a.onclick = (e) => {
            e.preventDefault();
            selectMethod(method);
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('method', method);
            history.replaceState({}, '', newUrl);
            };
            a.innerHTML = `
            <div class="ico"></div>
            <div class="lbl">${label}</div>
            `;
            typesNav.appendChild(a);
        });
    }

    function renderFilters() {
      filtersRow.innerHTML = '';
      const caps = methodCapabilities[selectedMethod];
      if (!caps || !Array.isArray(caps.filters) || !caps.filters.length) {
        // No filters available for this method
        return;
      }
      caps.filters.forEach(filter => {
        const label = document.createElement('label');
        label.style.display = 'block';
        label.style.minWidth = '140px';
        label.style.whiteSpace = 'nowrap';
        const nameSpan = document.createElement('span');
        nameSpan.style.fontSize = '12px';
        nameSpan.style.color = 'var(--muted)';
        nameSpan.style.display = 'block';
        nameSpan.style.marginBottom = '4px';
        nameSpan.textContent = (filter.name || '').trim();
        label.title = filter.description || '';
        label.appendChild(nameSpan);

        let input;
        if (Array.isArray(filter.choices)) {
          input = document.createElement('select');
          input.className = 'sel';
          filter.choices.forEach(choice => {
            const opt = document.createElement('option');
            opt.value = choice;
            opt.textContent = choice;
            input.appendChild(opt);
          });
          input.value = (filterValues[filter.name] !== undefined) ? filterValues[filter.name] : (filter.default !== undefined ? filter.default : (filter.choices[0] || ''));
        } else {
          input = document.createElement('input');
          input.type = 'text';
          input.className = 'flt-input';
          input.value = (filterValues[filter.name] !== undefined) ? filterValues[filter.name] : (filter.default !== undefined ? filter.default : '');
        }
        input.onchange = () => {
          filterValues[filter.name] = input.value;
        };
        label.appendChild(input);
        filtersRow.appendChild(label);
      });
    }

    function restoreDefaultResultsLayout() {
      mainIslandsDiv.innerHTML = '';
      resultsDiv.innerHTML = '';
      supportingIslands.innerHTML = '';
    }

    function selectMethod(method) {
      selectedMethod = method;
      currentPage = 1;
      renderMethods();
      renderFilters();
      restoreDefaultResultsLayout();
      renderPagination(); // Show/hide pager according to capabilities
    }

    function renderPagination() {
      if (!pagerDiv) return;
      pagerDiv.innerHTML = '';
      const caps = methodCapabilities[selectedMethod];
      if (!selectedMethod || !caps || !caps.pagination) {
        pagerDiv.style.display = 'none';
        return;
      }
      pagerDiv.style.display = 'flex';
      const pageParam = caps.pageParam || 'p';
      const maxPage = caps.maxPage || 100;

      const prevBtn = document.createElement('button');
      prevBtn.className = 'btn';
      prevBtn.textContent = 'Previous';
      prevBtn.disabled = currentPage <= 1;
      prevBtn.onclick = (e) => {
        e.preventDefault();
        if (currentPage > 1) {
          currentPage--;
          handleSearch();
        }
      };

      const nextBtn = document.createElement('button');
      nextBtn.className = 'btn';
      nextBtn.textContent = 'Next';
      nextBtn.disabled = currentPage >= maxPage;
      nextBtn.onclick = (e) => {
        e.preventDefault();
        if (currentPage < maxPage) {
          currentPage++;
          handleSearch();
        }
      };

      const pageInfo = document.createElement('span');
      pageInfo.textContent = `Page ${currentPage} of ${maxPage}`;

      pagerDiv.appendChild(prevBtn);
      pagerDiv.appendChild(pageInfo);
      pagerDiv.appendChild(nextBtn);
    }

    function highlightKeyword(text, keyword) {
      if (!text || !keyword) return text || '';
      const safe = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      return text.replace(new RegExp(`(${safe})`, 'gi'), '<b>$1</b>');
    }

    function setSearchingState() {
      resultsDiv.innerHTML = '<div class="meta" style="padding:10px 0 6px 16px;">Searching...</div>';
    }

    async function handleSearch() {
      const query = (qInput.value || '').trim();
      if (!query || !selectedMethod) return;

      // Update ?q= in URL (no reload)
      const newUrl = new URL(window.location.href);
      newUrl.searchParams.set('q', query);
      history.replaceState({}, '', newUrl);

      restoreDefaultResultsLayout();
      setSearchingState();

      let body = { query, method: selectedMethod };
      let rankingPreferences = {};

      const caps = methodCapabilities[selectedMethod] || {};
      if (caps.pagination) {
        const pageParam = caps.pageParam || 'p';
        rankingPreferences[pageParam] = currentPage;
      }
      if (Array.isArray(caps.filters)) {
        caps.filters.forEach(filter => {
          if (filterValues[filter.name] !== undefined && filterValues[filter.name] !== '') {
            rankingPreferences[filter.name] = filterValues[filter.name];
          } else if (filter.default !== undefined) {
            rankingPreferences[filter.name] = filter.default;
          }
        });
      }
      if (Object.keys(rankingPreferences).length > 0) {
        body.rankingPreferences = rankingPreferences;
      }

      try {
        const res = await fetch(NODE + '/search', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        const data = await res.json();

        // Update currentPage from response meta if present
        if (data.meta && typeof data.meta.page === 'number') {
          currentPage = data.meta.page;
        }
        renderPagination();

        // Custom HTML layout
        const html = (typeof data.html === 'string' && data.html.trim()) ? data.html : null;
        if (html) {
          resultsDiv.innerHTML = html;
          return;
        }

        // Islands
        if (Array.isArray(data.islands) && data.islands.length) {
          const mainIslands = data.islands.filter(island => island.column === 'main' && typeof island.html === 'string');
          const suppIslands = data.islands.filter(island => island.column === 'supporting' && typeof island.html === 'string');

          mainIslandsDiv.innerHTML = mainIslands.map(island => `
            <article class="island">
              <div class="head">${island.name || ''}</div>
              <div class="inner">
                <div style="grid-column: 1 / -1;">
                  ${island.html}
                </div>
              </div>
            </article>
          `).join('');

          supportingIslands.innerHTML = suppIslands.map(island => `
            <article class="island">
              <div class="head">${island.name || ''}</div>
              <div class="inner">
                <div style="grid-column: 1 / -1;">
                  ${island.html}
                </div>
              </div>
            </article>
          `).join('');
        } else {
          supportingIslands.innerHTML = '';
          mainIslandsDiv.innerHTML = '';
        }

        // Results
        const answers = Array.isArray(data.answers) ? data.answers : [];
        if (!answers.length) {
          resultsDiv.innerHTML = '<div class="meta" style="padding:10px 0 6px 16px;">No results</div>';
          return;
        }

        let lastDomain = null;
        let out = '';
        answers.forEach((a, i) => {
          const isNewDomain = a.domain !== lastDomain;
          if (isNewDomain) {
            if (lastDomain !== null) out += '</div>'; // close previous group
            out += '<div class="results-group">';
          }
          out += `
            <div class="result">
              <a href="${a.url}" target="_blank" rel="noopener noreferrer">${highlightKeyword(a.name || a.url || '', query)}</a>
              <div class="url">${a.domain || ''}</div>
              <div class="meta">${highlightKeyword(a.snippet || '', query)}</div>
            </div>
          `;
          lastDomain = a.domain;
          const next = answers[i + 1];
          if (!next || next.domain !== a.domain) {
            out += '</div>'; // close group
          }
        });
        resultsDiv.innerHTML = out;

      } catch (err) {
        resultsDiv.innerHTML = `<div class="meta" style="padding:10px 0 6px 16px; color:#c00;">${(err && err.message) || 'Search failed'}</div>`;
        renderPagination();
      }
    }

    // Suggestions
    (function setupSuggestions() {
      if (!qInput || !suggestionsDiv) return;

      let list = [];
      let selectedIdx = -1;
      let debounceTimeout = null;
      let lastFetchId = 0;

      function showSuggestions(items) {
        suggestionsDiv.innerHTML = '';
        if (!items.length) {
          suggestionsDiv.style.display = 'none';
          return;
        }
        items.forEach((s, i) => {
          const item = document.createElement('div');
          item.className = 'suggestion-item' + (i === selectedIdx ? ' selected' : '');
          item.textContent = s;
          item.onclick = () => {
            qInput.value = s;
            suggestionsDiv.style.display = 'none';
            qInput.focus();
          };
          suggestionsDiv.appendChild(item);
        });
        suggestionsDiv.style.display = 'block';
      }

      async function fetchSuggestions(query) {
        if (!query) return [];
        try {
          const res = await fetch(NODE + '/suggest', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ partial: query })
          });
          if (!res.ok) return [];
          const data = await res.json();
          if (Array.isArray(data.suggestions)) return data.suggestions;
          return [];
        } catch {
          return [];
        }
      }

      qInput.addEventListener('input', () => {
        const val = qInput.value.trim();
        selectedIdx = -1;
        if (debounceTimeout) clearTimeout(debounceTimeout);
        if (!val) {
          list = [];
          showSuggestions([]);
          return;
        }
        const fetchId = ++lastFetchId;
        debounceTimeout = setTimeout(async () => {
          const sugg = await fetchSuggestions(val);
          if (fetchId !== lastFetchId) return;
          list = sugg;
          showSuggestions(list);
        }, 180);
      });

      qInput.addEventListener('keydown', (e) => {
        if (!list.length || suggestionsDiv.style.display === 'none') return;
        if (e.key === 'ArrowDown') {
          selectedIdx = (selectedIdx + 1) % list.length;
          showSuggestions(list);
          e.preventDefault();
        } else if (e.key === 'ArrowUp') {
          selectedIdx = (selectedIdx - 1 + list.length) % list.length;
          showSuggestions(list);
          e.preventDefault();
        } else if (e.key === 'Enter') {
          if (selectedIdx >= 0 && selectedIdx < list.length) {
            qInput.value = list[selectedIdx];
            suggestionsDiv.style.display = 'none';
            e.preventDefault();
          }
        } else if (e.key === 'Escape') {
          suggestionsDiv.style.display = 'none';
        }
      });

      document.addEventListener('click', (e) => {
        if (!suggestionsDiv.contains(e.target) && e.target !== qInput) {
          suggestionsDiv.style.display = 'none';
        }
      });
    })();

    // Wire up search
    searchForm.addEventListener('submit', (e) => {
      e.preventDefault();
      handleSearch();
    });
    goBtn.addEventListener('click', () => handleSearch());

    // Boot
    fetchMethods();
  </script>
</body>

</html>