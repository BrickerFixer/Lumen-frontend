<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Index — Pong Doodle</title>
  <link rel="stylesheet" href="/resources/styles/branding.css">
  <style>
    /* Doodle-specific; base look comes from branding.css */

    /* Canvas behind everything */
    .pong-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    /* Keep the word visible above canvas */
    .logo {
      z-index: 2;
    }

    /* The real interactive I (paddle), separate from the word */
    .i-paddle {
      position: absolute;
      z-index: 3;
      display: inline-block;
      line-height: 1;
      touch-action: none;
      cursor: grab;
      user-select: none;
    }
    .i-paddle:active { cursor: grabbing; }

    /* Hidden “ghost” I inside the word — only for layout/measurements */
    .i-ghost {
      visibility: hidden;
      pointer-events: none;
    }

    /* Score chip */
    .score {
      position: absolute;
      right: 8px;
      top: 8px;
      z-index: 4;
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--muted);
      background: color-mix(in oklab, var(--bg), transparent 15%);
      border: 1px solid var(--hair);
      padding: 4px 8px;
      border-radius: 10px;
      backdrop-filter: saturate(1.2) blur(2px);
    }

    /* Keep hints above canvas too */
    .hint { z-index: 4; }
  </style>
</head>
<body>
  <div id="stage" class="stage" tabindex="0"
       aria-label="Index pong doodle. Press Space to play; drag the I or use arrow keys to move.">
    <!-- Canvas back layer -->
    <canvas id="pongCanvas" class="pong-canvas" width="600" height="160" aria-hidden="true"></canvas>

    <!-- Centered word with hidden I for layout -->
    <div id="logo" class="logo" aria-hidden="false">
      <span id="iGhost" class="i i-ghost">I</span><span class="rest">ndex</span>
    </div>

    <!-- Interactive I paddle (separate element) -->
    <div id="iPaddle" class="i-paddle logo" aria-hidden="true">
      <span id="iGlyph" class="i">I</span>
    </div>

    <div id="score" class="score">Score 0</div>
    <div class="hint">Space: play • drag the I</div>
  </div>

  <script>
  (() => {
    const stage = document.getElementById('stage');
    const iGhost = document.getElementById('iGhost');   // hidden in-word I (for measuring)
    const iPaddle = document.getElementById('iPaddle'); // interactive I container
    const iGlyph = document.getElementById('iGlyph');   // actual I character inside paddle
    const canvas = document.getElementById('pongCanvas');
    const scoreEl = document.getElementById('score');
    const ctx = canvas.getContext('2d');

    // State
    let playing = false, rafId = 0, score = 0;

    const ball = { x: 40, y: 30, vx: 2.2, vy: 1.3, r: 6 };

    // Paddle geometry relative to stage
    let baseLeft = 0, baseRight = 0, baseTop = 0, baseWidth = 0, baseHeight = 0;
    let iOffset = 0;

    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const css = (prop) => getComputedStyle(document.documentElement).getPropertyValue(prop).trim();

    function resize() {
      const rect = stage.getBoundingClientRect();
      const dpr = Math.min(window.devicePixelRatio || 1, 2);

      canvas.width = Math.max(1, Math.floor(rect.width * dpr));
      canvas.height = Math.max(1, Math.floor(rect.height * dpr));
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      measurePaddle();
      applyPaddle();
    }

    function measurePaddle() {
      // Measure the (hidden) I inside the word to know where it sits
      const rectStage = stage.getBoundingClientRect();
      const rI = iGhost.getBoundingClientRect();

      baseLeft = rI.left - rectStage.left;
      baseRight = rectStage.right - rI.right;
      baseTop = rI.top - rectStage.top;
      baseWidth = rI.width;
      baseHeight = rI.height;

      // Place the paddle at the measured position (translate handles movement)
      iPaddle.style.left = Math.round(baseLeft) + 'px';
      iPaddle.style.top = Math.round(baseTop) + 'px';
      iPaddle.style.transform = 'translateX(0px)';
      iOffset = 0;
    }

    function applyPaddle() {
      // Allow the I to travel from the very left to very right inside the stage
      const leftLimit = -baseLeft;
      const rightLimit = baseRight;
      iOffset = clamp(iOffset, leftLimit, rightLimit);
      iPaddle.style.transform = `translateX(${Math.round(iOffset)}px)`;
    }

    function start() {
      playing = true;
      score = 0;
      scoreEl.textContent = 'Score ' + score;
      const rect = stage.getBoundingClientRect();
      ball.x = clamp(rect.width * 0.35, 20, rect.width - 20);
      ball.y = 20;
      ball.vx = (Math.random() * 2 + 1.2) * (Math.random() < 0.5 ? -1 : 1);
      ball.vy = 1.2;
      loop();
    }
    function stop() { playing = false; cancelAnimationFrame(rafId); clearCanvas(); }
    function toggle() { playing ? stop() : start(); }

    function loop() { step(); draw(); rafId = requestAnimationFrame(loop); }

    function step() {
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const gravity = 0.08;

      ball.vy += gravity;
      ball.x += ball.vx;
      ball.y += ball.vy;

      if (ball.x < ball.r) { ball.x = ball.r; ball.vx *= -1; }
      if (ball.x > w - ball.r) { ball.x = w - ball.r; ball.vx *= -1; }
      if (ball.y < ball.r) { ball.y = ball.r; ball.vy *= -1; }

      if (ball.y > h - ball.r) {
        ball.y = h - ball.r;
        ball.vy *= -0.8;
        score = Math.max(0, score - 1);
        scoreEl.textContent = 'Score ' + score;
        flash(css('--acc') || '#92BAC2');
      }

      // Paddle collision (use base + offset)
      const paddle = { x: baseLeft + iOffset, y: baseTop, w: baseWidth, h: baseHeight };
      if (circleRect(ball.x, ball.y, ball.r, paddle)) {
        const rel = (ball.x - paddle.x) / paddle.w - 0.5; // -0.5..0.5
        ball.vy = -Math.abs(ball.vy) - 1.1;
        ball.vx += rel * 2.0;
        score += 1;
        scoreEl.textContent = 'Score ' + score;
        wobbleI(rel);
        flash(css('--acc') || '#92BAC2');
      }
    }

    function circleRect(cx, cy, cr, r) {
      const tx = Math.max(r.x, Math.min(cx, r.x + r.w));
      const ty = Math.max(r.y, Math.min(cy, r.y + r.h));
      const dx = cx - tx, dy = cy - ty;
      return dx*dx + dy*dy <= cr*cr;
    }

    function clearCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); }

    function draw() {
      clearCanvas();
      const acc = css('--acc') || '#92BAC2';
      const hair = css('--hair') || 'rgba(0,0,0,.08)';

      // Ball
      ctx.beginPath();
      ctx.fillStyle = acc;
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
      ctx.fill();

      // Ground hairline
      ctx.strokeStyle = hair;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, canvas.clientHeight - 0.5);
      ctx.lineTo(canvas.clientWidth, canvas.clientHeight - 0.5);
      ctx.stroke();
    }

    function wobbleI(dir) {
      iGlyph.style.rotate = (dir * 4) + 'deg';
      clearTimeout(wobbleI._t);
      wobbleI._t = setTimeout(() => iGlyph.style.rotate = '0deg', 100);
    }

    let flashT;
    function flash(color) {
      stage.style.boxShadow = `inset 0 0 0 6px ${color}33`; // 20% alpha
      clearTimeout(flashT);
      flashT = setTimeout(() => stage.style.boxShadow = '', 140);
    }

    // Controls
    stage.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); toggle(); }
      const stepX = 14;
      if (e.key === 'ArrowLeft') { iOffset -= stepX; applyPaddle(); }
      if (e.key === 'ArrowRight') { iOffset += stepX; applyPaddle(); }
    });

    // Drag the I (or anywhere on stage if you prefer)
    stage.addEventListener('pointerdown', (e) => { stage.setPointerCapture(e.pointerId); drag(e); });
    stage.addEventListener('pointermove', drag);
    function drag(e) {
      if (e.pressure === 0 && e.buttons === 0) return;
      const rect = stage.getBoundingClientRect();
      const target = e.clientX - rect.left;
      iOffset = target - (baseLeft + baseWidth / 2);
      applyPaddle();
    }

    // Setup
    function init() {
      resize();
      if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(resize);
      }
      stage.focus();
    }
    window.addEventListener('resize', resize);
    document.addEventListener('visibilitychange', () => { if (document.hidden && playing) stop(); });
    init();
  })();
  </script>
</body>
</html>