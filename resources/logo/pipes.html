<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lumen Ã— Windows XP Pipes</title>
    <link rel="stylesheet" href="/resources/styles/branding.css">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
        }
        #stage {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
            width: 100%;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="stage" class="stage" aria-live="polite" aria-label="Lumen logo">
        <div id="logo" class="logo"><span class="rest">Lumen</span></div>
        <div class="hint">Lumen loves: Classic Screensavers</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const vsSource = `
            attribute vec3 aPosition;
            attribute vec3 aColor;
            uniform mat4 uProjection;
            uniform mat4 uView;
            varying vec3 vColor;
            void main() {
                gl_Position = uProjection * uView * vec4(aPosition, 1.0);
                vColor = aColor;
            }
        `;

        const fsSource = `
            precision mediump float;
            varying vec3 vColor;
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        const aPosition = gl.getAttribLocation(program, 'aPosition');
        const aColor = gl.getAttribLocation(program, 'aColor');
        const uProjection = gl.getUniformLocation(program, 'uProjection');
        const uView = gl.getUniformLocation(program, 'uView');

        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);

        function perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) / (near - far), -1,
                0, 0, (2 * far * near) / (near - far), 0
            ]);
        }

        const colors = [
            [1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0], 
            [1, 0, 1], [0, 1, 1], [1, 0.5, 0], [0.5, 0, 1]
        ];

        class Pipe {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.floor(Math.random() * 20 - 10);
                this.y = Math.floor(Math.random() * 20 - 10);
                this.z = Math.floor(Math.random() * 20 - 10);
                this.dir = Math.floor(Math.random() * 6);
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.segments = [];
                this.length = 0;
                this.maxLength = 128 + Math.floor(Math.random() * 50);
            }

            update() {
                if (this.length >= this.maxLength) {
                    this.reset();
                    return;
                }

                const prevX = this.x;
                const prevY = this.y;
                const prevZ = this.z;

                if (Math.random() < 0.1) {
                    const oldDir = this.dir;
                    this.dir = Math.floor(Math.random() * 6);
                    while (this.dir === oldDir || this.dir === (oldDir < 3 ? oldDir + 3 : oldDir - 3)) {
                        this.dir = Math.floor(Math.random() * 6);
                    }
                }

                switch(this.dir) {
                    case 0: this.x++; break;
                    case 1: this.y++; break;
                    case 2: this.z++; break;
                    case 3: this.x--; break;
                    case 4: this.y--; break;
                    case 5: this.z--; break;
                }

                this.segments.push({
                    x1: prevX, y1: prevY, z1: prevZ,
                    x2: this.x, y2: this.y, z2: this.z,
                    dir: this.dir
                });

                this.length++;
            }

            getVertices() {
                const vertices = [];
                const colorData = [];

                this.segments.forEach(seg => {
                    const r = 0.15;
                    const verts = this.createPipeSegment(seg.x1, seg.y1, seg.z1, seg.x2, seg.y2, seg.z2, r, seg.dir);
                    vertices.push(...verts);
                    for (let i = 0; i < verts.length / 3; i++) {
                        colorData.push(...this.color);
                    }
                });

                return { vertices, colors: colorData };
            }

            createPipeSegment(x1, y1, z1, x2, y2, z2, r, dir) {
                const verts = [];
                const segments = 8;

                for (let i = 0; i < segments; i++) {
                    const a1 = (i / segments) * Math.PI * 2;
                    const a2 = ((i + 1) / segments) * Math.PI * 2;

                    let p1, p2, p3, p4;

                    if (dir < 2) {
                        p1 = [x1 + r * Math.cos(a1), y1 + r * Math.sin(a1), z1];
                        p2 = [x1 + r * Math.cos(a2), y1 + r * Math.sin(a2), z1];
                        p3 = [x2 + r * Math.cos(a1), y2 + r * Math.sin(a1), z2];
                        p4 = [x2 + r * Math.cos(a2), y2 + r * Math.sin(a2), z2];
                    } else if (dir < 4) {
                        p1 = [x1 + r * Math.cos(a1), y1, z1 + r * Math.sin(a1)];
                        p2 = [x1 + r * Math.cos(a2), y1, z1 + r * Math.sin(a2)];
                        p3 = [x2 + r * Math.cos(a1), y2, z2 + r * Math.sin(a1)];
                        p4 = [x2 + r * Math.cos(a2), y2, z2 + r * Math.sin(a2)];
                    } else {
                        p1 = [x1, y1 + r * Math.cos(a1), z1 + r * Math.sin(a1)];
                        p2 = [x1, y1 + r * Math.cos(a2), z1 + r * Math.sin(a2)];
                        p3 = [x2, y2 + r * Math.cos(a1), z2 + r * Math.sin(a1)];
                        p4 = [x2, y2 + r * Math.cos(a2), z2 + r * Math.sin(a2)];
                    }

                    verts.push(...p1, ...p3, ...p2, ...p2, ...p3, ...p4);
                }

                return verts;
            }
        }

        const pipes = [];
        for (let i = 0; i < 8; i++) {
            pipes.push(new Pipe());
        }

        let camAngle = 0;

        function render() {
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const aspect = canvas.width / canvas.height;
            const projMatrix = perspective(Math.PI / 4, aspect, 0.1, 100.0);
            gl.uniformMatrix4fv(uProjection, false, projMatrix);

            camAngle += 0.002;
            const camDist = 25;
            const camX = Math.cos(camAngle) * camDist;
            const camZ = Math.sin(camAngle) * camDist;
            const camY = 5;

            const viewMatrix = lookAt(camX, camY, camZ, 0, 0, 0, 0, 1, 0);
            gl.uniformMatrix4fv(uView, false, viewMatrix);

            pipes.forEach(pipe => pipe.update());

            pipes.forEach(pipe => {
                const { vertices, colors: pipeColors } = pipe.getVertices();
                if (vertices.length === 0) return;

                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(aPosition);
                gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

                const colBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, colBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pipeColors), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(aColor);
                gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);

                gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 3);
            });

            requestAnimationFrame(render);
        }

        function lookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
            const zx = eyeX - centerX;
            const zy = eyeY - centerY;
            const zz = eyeZ - centerZ;
            let len = Math.sqrt(zx * zx + zy * zy + zz * zz);
            const z = [zx / len, zy / len, zz / len];

            const xx = upY * z[2] - upZ * z[1];
            const xy = upZ * z[0] - upX * z[2];
            const xz = upX * z[1] - upY * z[0];
            len = Math.sqrt(xx * xx + xy * xy + xz * xz);
            const x = [xx / len, xy / len, xz / len];

            const y = [z[1] * x[2] - z[2] * x[1], z[2] * x[0] - z[0] * x[2], z[0] * x[1] - z[1] * x[0]];

            return new Float32Array([
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -(x[0] * eyeX + x[1] * eyeY + x[2] * eyeZ),
                -(y[0] * eyeX + y[1] * eyeY + y[2] * eyeZ),
                -(z[0] * eyeX + z[1] * eyeY + z[2] * eyeZ),
                1
            ]);
        }

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        });
        canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        render();
    </script>
</body>
</html>