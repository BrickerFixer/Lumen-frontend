<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Lumen Cocktail Logo</title>
  <link rel="stylesheet" href="/resources/styles/branding.css">
  <style>
    #canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: block;
    }
    html, body {
      margin: 0;
      height: 100%;
      background: #0d1117; /* fallback behind canvas */
    }
    .stage {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <div id="stage" class="stage" aria-live="polite" aria-label="Lumen cocktail logo">
    <canvas id="canvas"></canvas>

    <!-- Keep the structure but hide this visually; we’ll read its computed styles -->
    <div id="logo" class="logo"><span class="rest">Lumen</span></div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d', { alpha: true });
      const logoEl = document.getElementById('logo');

      let W = 0, H = 0, dpr = Math.min(window.devicePixelRatio || 1, 2);

      function resize() {
        dpr = Math.min(window.devicePixelRatio || 1, 2);
        W = window.innerWidth;
        H = window.innerHeight;
        canvas.width = Math.floor(W * dpr);
        canvas.height = Math.floor(H * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        computeBounds();
      }
      window.addEventListener('resize', resize);

      // Bounds: the entire canvas is the glass, with tiny padding so items don’t clip
      const bounds = { left: 0, right: 0, top: 0, bottom: 0, padding: 8 };
      function computeBounds() {
        bounds.left = bounds.padding;
        bounds.right = W - bounds.padding;
        bounds.top = bounds.padding;
        bounds.bottom = H - bounds.padding;
      }

      // Utilities
      const rand  = (a, b) => a + Math.random() * (b - a);
      const randi = (a, b) => Math.floor(rand(a, b + 1));
      const pick  = (arr) => arr[Math.floor(Math.random() * arr.length)];
      const chance = (p) => Math.random() < p;

      function hexWithAlpha(hex, alpha) {
        const c = hex.replace('#', '');
        const full = c.length === 3 ? c.split('').map(s => s + s).join('') : c;
        const n = parseInt(full, 16);
        const r = (n >> 16) & 255, g = (n >> 8) & 255, b = n & 255;
        return `rgba(${r},${g},${b},${alpha})`;
      }

      function parseTextShadow(shadowStr) {
        if (!shadowStr || shadowStr === 'none') return null;
        const first = shadowStr.split(',')[0].trim();
        const colorMatch = first.match(/(rgba?\([^)]+\)|hsla?\([^)]+\)|#[0-9a-fA-F]{3,8})/);
        let color = 'rgba(0,0,0,0.35)', nums = [];
        if (colorMatch) {
          color = colorMatch[1];
          const rest = first.replace(colorMatch[0], '').trim();
          nums = rest.split(/\s+/).map(v => parseFloat(v));
        } else {
          nums = first.split(/\s+/).map(v => parseFloat(v));
        }
        const [ox = 0, oy = 2, blur = 8] = nums;
        return { color, ox, oy, blur };
      }

      // Read brand styling from the DOM logo (then hide it)
      const brandText = {
        color: '#ffffff',
        fontFamily: 'ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial',
        fontWeight: '700',
        textShadow: null
      };
      function captureBrandStyle() {
        if (!logoEl) return;
        const probe = logoEl.querySelector('.rest') || logoEl;
        const cs = getComputedStyle(probe);
        brandText.color = cs.color || brandText.color;
        brandText.fontFamily = cs.fontFamily || brandText.fontFamily;
        brandText.fontWeight = cs.fontWeight || brandText.fontWeight;
        brandText.textShadow = parseTextShadow(cs.textShadow);
        // Hide visible DOM logo but keep it in DOM for styling
        logoEl.setAttribute('aria-hidden', 'true');
        logoEl.style.opacity = '0';
        logoEl.style.pointerEvents = 'none';
        logoEl.style.userSelect = 'none';
      }

      // Palettes and fruit types
      const palettes = [
        { name: "Tequila Sunrise", colors: ["#FF6A00","#FFD500"] },
        { name: "Mojito",          colors: ["#2ECC71","#A3F7B5"] },
        { name: "Blue Lagoon",     colors: ["#00C6FF","#0072FF"] },
        { name: "Sunset Cooler",   colors: ["#f857a6","#ff5858"] },
        { name: "Blackberry",      colors: ["#41295a","#2F0743"] },
        { name: "Grapefruit",      colors: ["#FF9966","#FF5E62"] },
        { name: "Ocean Breeze",    colors: ["#36D1DC","#5B86E5"] },
      ];

      const fruitTypes = [
        { key: "lemon",  label: "Lemon slice",  base: "#FFD84D", rind: "#F2C335" },
        { key: "lime",   label: "Lime slice",   base: "#B5F37D", rind: "#7DC75E" },
        { key: "orange", label: "Orange slice", base: "#FFB84D", rind: "#FF9933" },
        { key: "cherry", label: "Cherry",       base: "#E63946", rind: "#87C56A" },
        { key: "berry",  label: "Berry",        base: "#6D5BD0", rind: "#4A3FB6" },
      ];

      // Drink state
      let drink = {};
      let letters = [];
      let iceCubes = [];
      let fruits = [];
      let bubbles = [];

      const LETTER_SEQUENCE = "Lumen";
      let nextLetterIndex = 0;

      function rollDrinkOnce() {
        const pal = pick(palettes);
        const iceCount = randi(3, 9);
        const iceSize = 48;
        const fruitKind = pick(fruitTypes);
        const fruitCount = randi(0, 3);
        const fruitSize = 48;

        drink = {
          palette: pal,
          iceCount,
          iceSize,
          fruitKind,
          fruitCount,
          fruitSize,
          // Entire canvas is filled with cocktail
          liquidLevel: bounds.top,
          wavePhase: 0
        };

        letters.length = 0;
        iceCubes.length = 0;
        fruits.length = 0;
        bubbles.length = 0;
        nextLetterIndex = 0;

        // Seed fruits (start a bit below top so they sink in)
        for (let i = 0; i < drink.fruitCount; i++) {
          fruits.push(createFruit());
        }

        // Spawn the "Lumen" letters once (no more added after this)
        spawnInitialLetters();
      }

      function spawnInitialLetters() {
        for (let i = 0; i < LETTER_SEQUENCE.length; i++) {
          letters.push(createLetter());
        }
      }

      // Entities
      function createLetter() {
        const x = rand(bounds.left + 24, bounds.right - 24);
        const y = bounds.top - rand(10, 120); // appear just above the canvas then sink in
        const char = LETTER_SEQUENCE[nextLetterIndex++ % LETTER_SEQUENCE.length];
        const size = 96;
        const density = rand(1, 1.22); // >1 sinks
        const rotation = rand(-1, 1);
        return {
          type: "letter",
          char, x, y,
          vx: rand(-20, 20),
          vy: rand(20, 60),
          size, density,
          rotation,
          torque: rand(-0.08, 0.08)
          // No lifespan
        };
      }

      function createIce() {
        const x = rand(bounds.left + 20, bounds.right - 20);
        const y = bounds.bottom - rand(6, 22);
        const size = rand(drink.iceSize * 0.8, drink.iceSize * 1.2);
        return {
          type: "ice",
          x, y,
          vx: rand(-10, 10),
          vy: -rand(40, 90),
          rotation: rand(0, Math.PI),
          torque: rand(-0.6, 0.6),
          size,
          density: 0.92, // floats up
          bob: rand(0, Math.PI * 2)
        };
      }

      function createFruit() {
        const x = rand(bounds.left + 24, bounds.right - 24);
        const y = drink.liquidLevel + rand(8, 28);
        const size = rand(drink.fruitSize * 0.8, drink.fruitSize * 1.2);
        const kind = drink.fruitKind.key;
        const meta = fruitTypes.find(f => f.key === kind);

        let density = 1.06;
        if (kind === "cherry") density = 1.18;
        if (kind === "berry") density = 1.02;
        if (kind === "lime" || kind === "lemon" || kind === "orange") density = 1.05;

        const bubbleDelay = rand(1.2, 3.2) * 1000;
        const bubbleDuration = rand(0.8, 2.0) * 1000;

        return {
          type: "fruit",
          kind, meta,
          x, y,
          vx: rand(-12, 12),
          vy: rand(10, 30),
          rotation: rand(-0.4, 0.4),
          torque: rand(-0.3, 0.3),
          size, density,
          bubbleDelay, bubbleDuration,
          bubblesOn: false,
          lastToggle: performance.now()
        };
      }

      function spawnRisingBubble(x, baseY) {
        bubbles.push({
          x: x + rand(-6, 6),
          y: baseY + rand(-6, 6),
          vy: -rand(30, 70),
          vx: rand(-8, 8),
          r: rand(1, 3),
          alpha: rand(0.25, 0.55),
          life: rand(1.0, 2.0) * 1000,
          spawn: performance.now()
        });
        if (bubbles.length > 400) bubbles.splice(0, bubbles.length - 400);
      }

      // Physics helpers
      function inLiquid(x, y) {
        // Entire canvas is the cocktail, so anything in-bounds is submerged
        return y >= bounds.top && y <= bounds.bottom && x >= bounds.left && x <= bounds.right;
      }

      function confine(o, radius = 6) {
        if (o.x < bounds.left + radius) {
          o.x = bounds.left + radius; o.vx = Math.abs(o.vx) * 0.6;
        } else if (o.x > bounds.right - radius) {
          o.x = bounds.right - radius; o.vx = -Math.abs(o.vx) * 0.6;
        }
        if (o.y < bounds.top + radius) {
          o.y = bounds.top + radius; o.vy = Math.abs(o.vy) * 0.4;
        } else if (o.y > bounds.bottom - radius) {
          o.y = bounds.bottom - radius; o.vy = -Math.abs(o.vy) * 0.5;
        }
      }

      // Drawing
      function drawLiquid() {
        // Full-canvas gradient fill (no visible air/surface)
        const g = ctx.createLinearGradient(0, bounds.top, 0, bounds.bottom);
        g.addColorStop(0, hexWithAlpha(drink.palette.colors[0], 0.96));
        g.addColorStop(1, hexWithAlpha(drink.palette.colors[1], 0.98));
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, W, H);

        // Subtle vignette for depth
        const vg = ctx.createRadialGradient(W*0.5, H*0.4, 80, W*0.5, H*0.4, Math.max(W, H));
        vg.addColorStop(0, "rgba(0,0,0,0)");
        vg.addColorStop(1, "rgba(0,0,0,1)");
        ctx.fillStyle = vg;
        ctx.fillRect(0, 0, W, H);
      }

      function drawBubbles() {
        ctx.save();
        for (const b of bubbles) {
          ctx.globalAlpha = b.alpha;
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(255,255,255,0.7)";
          ctx.fill();
        }
        ctx.restore();
      }

      function roundedRect(x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
      }

      function drawIce(c) {
        const { x, y, size, rotation } = c;
        const s = size;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        const r = Math.max(2, s * 0.18);
        roundedRect(-s/2, -s/2, s, s, r);
        const g = ctx.createLinearGradient(-s/2, -s/2, s/2, s/2);
        g.addColorStop(0, "rgba(255,255,255,0.28)");
        g.addColorStop(1, "rgba(255,255,255,0.08)");
        ctx.fillStyle = g;
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.28)";
        ctx.lineWidth = 1;
        ctx.stroke();
        // highlight
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.ellipse(-s*0.15, -s*0.15, s*0.18, s*0.1, 0, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,255,255,0.35)";
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.restore();
      }

      function drawFruit(f) {
        const { x, y, size, rotation, meta, kind } = f;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);

        if (kind === "cherry") {
          ctx.beginPath();
          ctx.arc(0, 0, size * 0.6, 0, Math.PI * 2);
          ctx.fillStyle = meta.base;
          ctx.fill();
          ctx.globalAlpha = 0.5;
          ctx.beginPath();
          ctx.arc(-size*0.18, -size*0.18, size * 0.22, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(255,255,255,0.55)";
          ctx.fill();
          ctx.globalAlpha = 1;
          ctx.strokeStyle = meta.rind;
          ctx.lineWidth = Math.max(1, size*0.08);
          ctx.beginPath();
          ctx.moveTo(size*0.2, -size*0.2);
          ctx.quadraticCurveTo(size*0.5, -size*0.8, 0, -size);
          ctx.stroke();
        } else if (kind === "berry") {
          ctx.beginPath();
          ctx.arc(0, 0, size * 0.55, 0, Math.PI * 2);
          const g = ctx.createRadialGradient(-size*0.15, -size*0.15, size*0.1, 0, 0, size*0.6);
          g.addColorStop(0, "rgba(255,255,255,0.35)");
          g.addColorStop(1, meta.base);
          ctx.fillStyle = g;
          ctx.fill();
          ctx.fillStyle = "rgba(255,255,255,0.25)";
          for (let i = 0; i < 10; i++) {
            ctx.beginPath();
            ctx.arc(rand(-size*0.35, size*0.35), rand(-size*0.35, size*0.35), size*0.05, 0, Math.PI*2);
            ctx.fill();
          }
        } else {
          // Citrus wedge
          const r = size * 0.9;
          const angle = Math.PI * 0.7;
          ctx.rotate(-Math.PI/2);
          ctx.beginPath();
          ctx.arc(0, 0, r, -angle/2, angle/2);
          ctx.lineWidth = Math.max(3, size * 0.2);
          ctx.strokeStyle = meta.rind;
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(0, 0, r - ctx.lineWidth*0.7, -angle/2, angle/2);
          ctx.strokeStyle = meta.base;
          ctx.lineWidth = Math.max(6, size * 0.35);
          ctx.stroke();
          ctx.strokeStyle = "rgba(255,255,255,0.45)";
          ctx.lineWidth = 1;
        }

        ctx.restore();
      }

      function drawLetter(l) {
        ctx.save();
        ctx.translate(l.x, l.y);
        ctx.rotate(l.rotation);

        // Apply brand font styling to the canvas text
        const px = 96;
        ctx.font = `${brandText.fontWeight} ${px}px ${brandText.fontFamily}`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // Optional shadow derived from text-shadow
        if (brandText.textShadow) {
          ctx.shadowColor = brandText.textShadow.color;
          ctx.shadowOffsetX = brandText.textShadow.ox;
          ctx.shadowOffsetY = brandText.textShadow.oy;
          ctx.shadowBlur = brandText.textShadow.blur;
        } else {
          // Fallback subtle shadow
          ctx.shadowColor = "rgba(0,0,0,0.35)";
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 2;
          ctx.shadowBlur = 8;
        }

        ctx.fillStyle = brandText.color;
        ctx.fillText(l.char, 0, 0);

        ctx.restore();
      }

      // Update
      function update(dt, now) {
        // No periodic letter spawning — they were created once at startup

        // Bubbles
        for (let i = bubbles.length - 1; i >= 0; i--) {
          const b = bubbles[i];
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          b.alpha *= 0.996;
          if (now - b.spawn > b.life || !inLiquid(b.x, b.y)) {
            bubbles.splice(i, 1);
          }
        }

        // Physics constants
        const G = 240; // base accel (px/s^2) used for buoyancy-like effects

        // Letters: sink slowly in cocktail; never removed
        for (let i = letters.length - 1; i >= 0; i--) {
          const l = letters[i];

          if (inLiquid(l.x, l.y)) {
            l.vy += (l.density - 1) * G * dt; // sink
            l.vx *= 0.985;
            l.vy *= 0.985;
            if (chance(0.04)) spawnRisingBubble(l.x, l.y);
          } else {
            // Above the canvas before entering
            l.vy += G * dt;
            l.vx *= 0.998;
          }

          l.x += l.vx * dt;
          l.y += l.vy * dt;
          l.rotation += l.torque * dt;

          confine(l, Math.max(6, l.size * 0.4));
        }

        // Ice: rises to the top and bobs
        for (let i = 0; i < iceCubes.length; i++) {
          const c = iceCubes[i];
          if (inLiquid(c.x, c.y)) {
            const buoyUp = (1 - c.density) * G; // upward
            c.vy -= buoyUp * dt;
            c.vx *= 0.99;
            c.vy *= 0.99;
            // Bob gently near top boundary
            const targetY = bounds.top + 8 + Math.sin((now * 0.002) + c.bob) * 2.0;
            if (c.y < targetY + c.size * 0.08) {
              c.y = targetY + c.size * 0.08;
              c.vy *= -0.2;
              if (chance(0.02)) spawnRisingBubble(c.x, c.y);
            }
          }
          c.x += c.vx * dt;
          c.y += c.vy * dt;
          c.rotation += c.torque * dt * 0.06;
          confine(c, c.size * 0.5);
        }

        // Fruits: sink, then rise when bubbles attach
        for (let i = 0; i < fruits.length; i++) {
          const f = fruits[i];
          // Periodically toggle bubbles on/off
          if (!f.bubblesOn && now - f.lastToggle > f.bubbleDelay) {
            f.bubblesOn = true;
            f.lastToggle = now;
          } else if (f.bubblesOn && now - f.lastToggle > f.bubbleDuration) {
            f.bubblesOn = false;
            f.bubbleDelay = rand(1.6, 3.6) * 1000;
            f.bubbleDuration = rand(0.9, 1.8) * 1000;
            f.lastToggle = now;
          }

          const effDensity = f.bubblesOn ? (f.density - 0.18) : f.density;
          if (inLiquid(f.x, f.y)) {
            f.vy += (effDensity - 1) * G * 0.6 * dt; // negative when rising with bubbles
            f.vx *= 0.992;
            f.vy *= 0.992;
            if (f.bubblesOn && chance(0.12)) spawnRisingBubble(f.x, f.y);
          } else {
            f.vy += G * dt;
          }

          f.x += f.vx * dt;
          f.y += f.vy * dt;
          f.rotation += f.torque * dt * 0.15;

          confine(f, f.size * 0.6);
        }

        // Spawn ice progressively from bottom (unchanged)
        // If you also want only one-time ice spawn, move this to rollDrinkOnce like letters
        for (let i = iceCubes.length; i < drink.iceCount; i++) {
          // Let initial batch rise up immediately
          if (i === iceCubes.length) iceCubes.push(createIce());
        }
      }

      // Render
      function render() {
        // Clear
        ctx.clearRect(0, 0, W, H);
        // Full cocktail fill
        drawLiquid();

        // Draw contents
        drawBubbles();
        for (const c of iceCubes) drawIce(c);
        for (const f of fruits) drawFruit(f);
        for (const l of letters) drawLetter(l);
      }

      // Main loop
      let last = performance.now();
      function loop(now) {
        const dt = Math.min(0.032, (now - last) / 1000); // seconds
        last = now;
        update(dt, now);
        render();
        requestAnimationFrame(loop);
      }

      // Init
      resize();
      captureBrandStyle();
      rollDrinkOnce();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>