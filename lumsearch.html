<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lumen â€” Search</title>
  <link href="resources/styles/serp.css" rel="stylesheet">
  <link href="resources/styles/universal.css" rel="stylesheet">
</head>

<body>
  <header id="hdr" class="hdr" style="--hdr-h:72px">
    <div class="hdr-inner">
      <div class="bar">
        <a href="/" aria-label="Lumen home">
          <img class="logo-img" src="resources/service-icons/mini-mini.png" alt="Lumen">
        </a>

        <div class="search-table">
          <form class="search" id="searchForm" autocomplete="off">
            <input class="q" id="q" name="q" type="search" placeholder="Search the Lumen" autofocus />
            <div id="suggestions" class="suggestions-list" aria-label="Suggestions"></div>
          </form>
          <button id="goBtn" class="bar-search-button" type="button">Go</button>
        </div>

        <div style="display:flex; gap:8px;">
          <button id="filtersBtn" class="icon-btn" aria-label="Filters">
            <img class="icon" src="resources/svg/tune_24dp_E3E3E3_FILL0_wght400_GRAD0_opsz24.svg">
          </button>
          <button id="fastlaneBtn" class="icon-btn" aria-label="Fastlane">
            <img class="icon" src="resources/svg/dashboard_24dp_E3E3E3_FILL0_wght400_GRAD0_opsz24.svg">
          </button>
        </div>
      </div>

      <div id="filtersRow" class="filters hidden" aria-hidden="true">
        <!-- Dynamic filters will be rendered here -->
      </div>

      <div id="fastlane" class="fastlane" aria-hidden="true">
        <h1>"Livin' the life in the Fast Lane..."</h1>
        <h2>Fastlane is a go-to place for your searches and web surfing.</h2>
        <p>Be it your pinned searches, themes, backgrounds, nodes, preferences and more, they will stay in this place. Stay tuned! It's not really a priority right now, as I need to fix other issues and experience problems.</p>
      </div>
    </div>
  </header>

  <main class="page">
    <!-- Sidebar: dynamically filled with methods -->
    <nav id="typesNav" class="types" aria-label="Search types">
      <!-- Methods will be rendered here -->
    </nav>
    <div id="serp-layout" class="serp-layout">
      <!-- Main column: dynamic islands + results -->
      <section id="main" class="main" aria-label="Main results">
        <div id="mainIslands"></div>
        <div id="results"></div>
        <div id="pager" class="pager" style="display:none;"></div>
      </section>

      <!-- Misc/supporting islands -->
      <aside id="supportingIslands" class="aside" aria-label="Related">
        <!-- Supporting islands will be rendered here -->
      </aside>
    </div>
  </main>

  <script>
    // Header toggle logic (kept)
    const hdr = document.getElementById('hdr');
    const filtersBtn = document.getElementById('filtersBtn');
    const fastlaneBtn = document.getElementById('fastlaneBtn');
    const filtersRow = document.getElementById('filtersRow');
    const fastlane = document.getElementById('fastlane');
    let filtersOpen = false;
    let fastlaneOpen = false;

    function applyHeaderState() {
      hdr.classList.toggle('is-filters', filtersOpen);
      hdr.classList.toggle('is-fastlane', fastlaneOpen);
      filtersRow.classList.toggle('hidden', !filtersOpen);
      filtersRow.setAttribute('aria-hidden', String(!filtersOpen));
      fastlane.classList.toggle('open', fastlaneOpen);
      fastlane.setAttribute('aria-hidden', String(!fastlaneOpen));
    }

    filtersBtn.addEventListener('click', () => {
      filtersOpen = !filtersOpen;
      applyHeaderState();
    });

    fastlaneBtn.addEventListener('click', () => {
      fastlaneOpen = !fastlaneOpen;
      applyHeaderState();
    });

    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && (fastlaneOpen || filtersOpen)) {
        fastlaneOpen = false; filtersOpen = false; applyHeaderState();
      }
    });

    // ----------------- Old frontend logic ported -----------------
    const url = new URL(window.location.href);
    const NODE = url.searchParams.get('node') || 'http://localhost:3000';

    let methods = [];
    let selectedMethod = null;
    let methodCapabilities = {};
    let currentPage = 1;
    let filterValues = {};

    const typesNav = document.getElementById('typesNav');
    const searchForm = document.getElementById('searchForm');
    const qInput = document.getElementById('q');
    const goBtn = document.getElementById('goBtn');
    const suggestionsDiv = document.getElementById('suggestions');
    const layoutDiv = document.getElementById('serp-layout');
    
    // These elements can be replaced, so we use `let` and re-assign them.
    let resultsDiv = document.getElementById('results');
    let mainIslandsDiv = document.getElementById('mainIslands');
    let supportingIslands = document.getElementById('supportingIslands');
    let pagerDiv = document.getElementById('pager');

// Portal the suggestions out of header to avoid clipping
document.body.appendChild(suggestionsDiv);
Object.assign(suggestionsDiv.style, {
  position: 'fixed',
  left: '0px',
  top: '0px',
  right: 'auto',
  display: 'none',
  zIndex: '9999'
});

const SUGG_MARGIN = 6;
let suggItems = [];
let suggIdx = -1;

function layoutSuggestions() {
  if (suggestionsDiv.style.display !== 'block') return;
  const r = qInput.getBoundingClientRect();
  if (!r.width || !r.height) return;

  // Default below input
  const belowTop = r.bottom + SUGG_MARGIN;
  const maxBelow = window.innerHeight - belowTop - 8;

  // Temporarily show to calculate intrinsic height
  const prevDisplay = suggestionsDiv.style.display;
  suggestionsDiv.style.display = 'block';
  const intrinsic = Math.min(240, suggestionsDiv.scrollHeight || 240);
  suggestionsDiv.style.display = prevDisplay;

  // If not enough room below, place above
  const placeAbove = maxBelow < Math.min(intrinsic, 180);
  const top = placeAbove
    ? Math.max(8, r.top - SUGG_MARGIN - Math.min(240, r.top - 8))
    : belowTop;

  suggestionsDiv.style.left = `${Math.round(r.left)}px`;
  suggestionsDiv.style.top = `${Math.round(top)}px`;
  suggestionsDiv.style.width = `${Math.round(r.width)}px`;
  suggestionsDiv.style.maxHeight = `${placeAbove ? Math.min(240, r.top - 8) : Math.min(240, maxBelow)}px`;
}

function showSuggestions(list) {
  suggestionsDiv.innerHTML = '';
  suggItems = list || [];
  suggIdx = -1;

  if (!suggItems.length) {
    suggestionsDiv.style.display = 'none';
    return;
  }

  for (let i = 0; i < suggItems.length; i++) {
    const s = suggItems[i];
    const item = document.createElement('div');
    item.className = 'suggestion-item';
    item.textContent = s;
    item.onclick = () => {
      qInput.value = s;
      suggestionsDiv.style.display = 'none';
      qInput.focus();
      // handleSearch(); // optional
    };
    suggestionsDiv.appendChild(item);
  }

  suggestionsDiv.style.display = 'block';
  layoutSuggestions();
}

// Keyboard navigation
qInput.addEventListener('keydown', (e) => {
  if (suggestionsDiv.style.display !== 'block' || !suggItems.length) return;

  if (e.key === 'ArrowDown') {
    suggIdx = (suggIdx + 1) % suggItems.length;
    [...suggestionsDiv.children].forEach((n, i) => n.classList.toggle('selected', i === suggIdx));
    e.preventDefault();
  } else if (e.key === 'ArrowUp') {
    suggIdx = (suggIdx - 1 + suggItems.length) % suggItems.length;
    [...suggestionsDiv.children].forEach((n, i) => n.classList.toggle('selected', i === suggIdx));
    e.preventDefault();
  } else if (e.key === 'Enter') {
    if (suggIdx >= 0 && suggIdx < suggItems.length) {
      qInput.value = suggItems[suggIdx];
      suggestionsDiv.style.display = 'none';
      e.preventDefault();
    }
  } else if (e.key === 'Escape') {
    suggestionsDiv.style.display = 'none';
  }
});

// Fetch + debounce
let debounceId = null;
let lastFetchId = 0;

async function fetchSuggestions(query) {
  if (!query) return [];
  try {
    const res = await fetch(NODE + '/suggest', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ partial: query })
    });
    if (!res.ok) return [];
    const data = await res.json();
    return Array.isArray(data.suggestions) ? data.suggestions : [];
  } catch {
    return [];
  }
}

qInput.addEventListener('input', () => {
  const val = qInput.value.trim();
  if (debounceId) clearTimeout(debounceId);

  if (!val) {
    suggestionsDiv.style.display = 'none';
    return;
  }

  const fetchId = ++lastFetchId;
  debounceId = setTimeout(async () => {
    const list = await fetchSuggestions(val);
    if (fetchId !== lastFetchId) return;
    showSuggestions(list);
  }, 180);
});

// Close on outside click
document.addEventListener('click', (e) => {
  if (!suggestionsDiv.contains(e.target) && e.target !== qInput) {
    suggestionsDiv.style.display = 'none';
  }
});

// Keep aligned during layout changes
const relayout = () => layoutSuggestions();
window.addEventListener('resize', relayout, { passive: true });
// Capture-phase scroll hits any scrollable ancestor
window.addEventListener('scroll', relayout, { passive: true, capture: true });
qInput.addEventListener('focus', relayout);

// Reflow when returning to tab or page is shown from bfcache
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') relayout();
});
window.addEventListener('pageshow', relayout);

// If you have a header toggle (filters/fastlane), re-run layout after it changes
const _applyHeaderState = applyHeaderState;
applyHeaderState = function () {
  _applyHeaderState();
  relayout();
};

// Optional: track direct size changes of the input (font zoom, container resize)
if ('ResizeObserver' in window) {
  const ro = new ResizeObserver(() => relayout());
  ro.observe(qInput);
}
function prettifyId(id) {
  return id
    .replace(/[-_]+/g, ' ')            // kebab/underscore to spaces
    .replace(/([a-z0-9])([A-Z])/g, '$1 $2') // split camelCase
    .replace(/\s+/g, ' ')
    .trim()
    .replace(/\b\w/g, c => c.toUpperCase()); // Title Case
}

function getMethodLabel(id) {
  const caps = methodCapabilities[id] || {};
  return caps.displayName || caps.label || caps.name || caps.title || prettifyId(id);
}

function getMethodDescription(id) {
  const caps = methodCapabilities[id] || {};
  return caps.description || '';
}

    function getParam(name) {
      return url.searchParams.get(name);
    }

    async function fetchMethods() {
      try {
        const res = await fetch(NODE + '/metadata');
        const data = await res.json();
        methods = data.methods || [];
        methodCapabilities = data.methodCapabilities || {};
        renderMethods();

        // Select method from URL ?method= or ?type=
        const urlMethod = getParam('method') || getParam('type');
        if (!selectedMethod && methods.length) {
          const pick = methods.includes(urlMethod) ? urlMethod : methods[0];
          selectMethod(pick);
        }

        // Pre-fill query
        const q = getParam('q');
        if (q) {
          qInput.value = q;
          // Optional: auto search when query exists
          handleSearch();
        }
      } catch (e) {
        console.error('Failed to fetch methods:', e);
      }
    }

    function renderMethods() {
        if (!typesNav) return;
        typesNav.innerHTML = '';
        methods.forEach((method) => {
            const label = getMethodLabel(method);
            const desc = getMethodDescription(method);
            const a = document.createElement('a');
            a.className = 'type';
            if (method === selectedMethod) a.setAttribute('aria-current', 'page');
            a.href = '#';
            a.title = desc || label; // nice hover text if you have description
            a.onclick = (e) => {
            e.preventDefault();
            selectMethod(method);
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('method', method);
            history.replaceState({}, '', newUrl);
            };
            a.innerHTML = `
            <div class="ico"></div>
            <div class="lbl">${label}</div>
            `;
            typesNav.appendChild(a);
        });
    }

    function renderFilters() {
      filtersRow.innerHTML = '';
      const caps = methodCapabilities[selectedMethod];
      if (!caps || !Array.isArray(caps.filters) || !caps.filters.length) {
        // No filters available for this method
        return;
      }
      caps.filters.forEach(filter => {
        const label = document.createElement('label');
        label.style.display = 'block';
        label.style.minWidth = '140px';
        label.style.whiteSpace = 'nowrap';
        const nameSpan = document.createElement('span');
        nameSpan.style.fontSize = '12px';
        nameSpan.style.color = 'var(--muted)';
        nameSpan.style.display = 'block';
        nameSpan.style.marginBottom = '4px';
        nameSpan.textContent = (filter.name || '').trim();
        label.title = filter.description || '';
        label.appendChild(nameSpan);

        let input;
        if (Array.isArray(filter.choices)) {
          input = document.createElement('select');
          input.className = 'sel';
          filter.choices.forEach(choice => {
            const opt = document.createElement('option');
            opt.value = choice;
            opt.textContent = choice;
            input.appendChild(opt);
          });
          input.value = (filterValues[filter.name] !== undefined) ? filterValues[filter.name] : (filter.default !== undefined ? filter.default : (filter.choices[0] || ''));
        } else {
          input = document.createElement('input');
          input.type = 'text';
          input.className = 'flt-input';
          input.value = (filterValues[filter.name] !== undefined) ? filterValues[filter.name] : (filter.default !== undefined ? filter.default : '');
        }
        input.onchange = () => {
          filterValues[filter.name] = input.value;
        };
        label.appendChild(input);
        filtersRow.appendChild(label);
      });
    }

    function restoreDefaultSerpLayout() {
      layoutDiv.innerHTML = `
        <section id="main" class="main" aria-label="Main results">
          <div id="mainIslands"></div>
          <div id="results"></div>
          <div id="pager" class="pager" style="display:none;"></div>
        </section>
        <aside id="supportingIslands" class="aside" aria-label="Related">
        </aside>
      `;
      // Re-assign variables to the new DOM elements
      mainIslandsDiv = document.getElementById('mainIslands');
      resultsDiv = document.getElementById('results');
      supportingIslands = document.getElementById('supportingIslands');
      pagerDiv = document.getElementById('pager');
    }

    function selectMethod(method) {
      selectedMethod = method;
      currentPage = 1;
      renderMethods();
      renderFilters();
      restoreDefaultSerpLayout();
      renderPagination(); // Show/hide pager according to capabilities
    }

    function renderPagination() {
      if (!pagerDiv) return;
      pagerDiv.innerHTML = '';
      const caps = methodCapabilities[selectedMethod];
      if (!selectedMethod || !caps || !caps.pagination) {
        pagerDiv.style.display = 'none';
        return;
      }
      pagerDiv.style.display = 'flex';
      const pageParam = caps.pageParam || 'p';
      const maxPage = caps.maxPage || 100;

      const prevBtn = document.createElement('button');
      prevBtn.className = 'btn';
      prevBtn.textContent = 'Previous';
      prevBtn.disabled = currentPage <= 1;
      prevBtn.onclick = (e) => {
        e.preventDefault();
        if (currentPage > 1) {
          currentPage--;
          handleSearch();
        }
      };

      const nextBtn = document.createElement('button');
      nextBtn.className = 'btn';
      nextBtn.textContent = 'Next';
      nextBtn.disabled = currentPage >= maxPage;
      nextBtn.onclick = (e) => {
        e.preventDefault();
        if (currentPage < maxPage) {
          currentPage++;
          handleSearch();
        }
      };

      const pageInfo = document.createElement('span');
      pageInfo.textContent = `Page ${currentPage} of ${maxPage}`;

      pagerDiv.appendChild(prevBtn);
      pagerDiv.appendChild(pageInfo);
      pagerDiv.appendChild(nextBtn);
    }

    function highlightKeyword(text, keyword) {
      if (!text || !keyword) return text || '';
      const safe = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      return text.replace(new RegExp(`(${safe})`, 'gi'), '<b>$1</b>');
    }

    function setSearchingState() {
      if (!resultsDiv) return;
      resultsDiv.innerHTML = '<div class="meta" style="padding:10px 0 6px 16px;">Searching...</div>';
    }

    async function handleSearch() {
      const query = (qInput.value || '').trim();
      if (!query || !selectedMethod) return;

      // Update ?q= in URL (no reload)
      const newUrl = new URL(window.location.href);
      newUrl.searchParams.set('q', query);
      history.replaceState({}, '', newUrl);
      
      // Restore the default layout structure and re-wire element variables.
      restoreDefaultSerpLayout();
      setSearchingState();

      let body = { query, method: selectedMethod };
      let rankingPreferences = {};

      const caps = methodCapabilities[selectedMethod] || {};
      if (caps.pagination) {
        const pageParam = caps.pageParam || 'p';
        rankingPreferences[pageParam] = currentPage;
      }
      if (Array.isArray(caps.filters)) {
        caps.filters.forEach(filter => {
          if (filterValues[filter.name] !== undefined && filterValues[filter.name] !== '') {
            rankingPreferences[filter.name] = filterValues[filter.name];
          } else if (filter.default !== undefined) {
            rankingPreferences[filter.name] = filter.default;
          }
        });
      }
      if (Object.keys(rankingPreferences).length > 0) {
        body.rankingPreferences = rankingPreferences;
      }

      // Make parallel requests for search results and islands
      const searchPromise = fetch(NODE + '/search', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });

      const islandsPromise = fetch(NODE + '/islands', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query, method: selectedMethod })
      });

      let usedCustomLayout = false;

      try {
        // Handle search results
        const searchRes = await searchPromise;
        const searchData = await searchRes.json();

        // Check for a full HTML override first
        const html = (typeof searchData.html === 'string' && searchData.html.trim()) ? searchData.html : null;
        if (html) {
          layoutDiv.innerHTML = html;
          usedCustomLayout = true;
          // When using a custom layout, it is responsible for the entire content.
          // We will not render the pager or islands.
        } else {
          // Proceed with standard rendering into the default layout
          if (searchData.meta && typeof searchData.meta.page === 'number') {
            currentPage = searchData.meta.page;
          }
          renderPagination();

          const answers = Array.isArray(searchData.answers) ? searchData.answers : [];
          if (!answers.length) {
            resultsDiv.innerHTML = '<div class="meta" style="padding:10px 0 6px 16px;">No results</div>';
          } else {
            let lastDomain = null;
            let out = '';
            answers.forEach((a, i) => {
              const isNewDomain = a.domain !== lastDomain;
              if (isNewDomain) {
                if (lastDomain !== null) out += '</div>'; // close previous group
                out += '<div class="results-group">';
              }
              out += `
                <div class="result">
                  <a href="${a.url}" target="_blank" rel="noopener noreferrer">${highlightKeyword(a.name || a.url || '', query)}</a>
                  <div class="url">${a.domain || ''}</div>
                  <div class="meta">${highlightKeyword(a.snippet || '', query)}</div>
                </div>
              `;
              lastDomain = a.domain;
              const next = answers[i + 1];
              if (!next || next.domain !== a.domain) {
                out += '</div>'; // close group
              }
            });
            resultsDiv.innerHTML = out;
          }
        }
      } catch (err) {
        if(resultsDiv) resultsDiv.innerHTML = `<div class="meta" style="padding:10px 0 6px 16px; color:#c00;">${(err && err.message) || 'Search failed'}</div>`;
        renderPagination();
      }

      // Only render islands if we are using the default layout
      if (!usedCustomLayout) {
        try {
          const islandsRes = await islandsPromise;
          const islandsData = await islandsRes.json();
          if (Array.isArray(islandsData.islands) && islandsData.islands.length) {
            const mainIslands = islandsData.islands.filter(island => island.column === 'main' && typeof island.html === 'string');
            const suppIslands = islandsData.islands.filter(island => island.column === 'supporting' && typeof island.html === 'string');

            if (mainIslandsDiv) mainIslandsDiv.innerHTML = mainIslands.map(island => `
              <article class="island">
                <div class="head">${island.name || ''}</div>
                <div class="inner"><div style="grid-column: 1 / -1;">${island.html}</div></div>
              </article>
            `).join('');

            if (supportingIslands) supportingIslands.innerHTML = suppIslands.map(island => `
              <article class="island">
                <div class="head">${island.name || ''}</div>
                <div class="inner"><div style="grid-column: 1 / -1;">${island.html}</div></div>
              </article>
            `).join('');
          }
        } catch (err) {
          // Silently fail islands loading - not critical
          if (mainIslandsDiv) mainIslandsDiv.innerHTML = '';
          if (supportingIslands) supportingIslands.innerHTML = '';
        }
      }
    }

    // Wire up search
    searchForm.addEventListener('submit', (e) => {
      e.preventDefault();
      handleSearch();
    });
    goBtn.addEventListener('click', () => handleSearch());

    // Boot
    fetchMethods();
  </script>
</body>

</html>