<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lumen</title>
  <link href="resources/styles/branding.css" rel="stylesheet">
  <link href="resources/styles/homepage.css" rel="stylesheet">
  <link href="resources/styles/universal.css" rel="stylesheet">
</head>
<body>
  <header id="hdr" class="hdr" style="--hdr-h:72px">
    <div class="hdr-inner">
      <div class="bar">
        <a href="/" aria-label="Lumen home"><img class="logo-img" src="resources/service-icons/mini-mini.png" alt="Lumen"></a>
        <div style="display:flex; gap:8px;">
          <button id="fastlaneBtn" class="icon-btn" aria-label="Fastlane">
            <img class="icon" src="resources/svg/dashboard_24dp_E3E3E3_FILL0_wght400_GRAD0_opsz24.svg">
          </button>
        </div>
      </div>

      <div id="fastlane" class="fastlane" aria-hidden="true">
        <h1>"Livin' the life in the Fast Lane..."</h1>
        <h2>Fastlane is a go-to place for your searches and web surfing.</h2>
        <p>Be it your pinned searches, themes, backgrounds, nodes, preferences and more, they will stay in this place. Stay tuned! It's not really a priority right now, as I need to fix other issues and experience problems.</p>
      </div>
    </div>
  </header>

  <main class="wrap">
    <div id="logo">
      <span class="i">L</span><span class="rest">umen</span>
    </div>

    <div class="search-table">
      <div class="search-stack" id="searchStack">
        <form class="search" id="homeSearchForm" autocomplete="off">
          <input class="q" id="q" name="q" type="search" placeholder="" autofocus />
        </form>

        <!-- Inline Advanced -->
        <div id="searchAdv" class="search-adv" aria-label="Advanced search">
          <div class="adv-grid">
            <label>
              <span class="lbl">Node</span>
              <input id="advNode" class="flt-input" placeholder="e.g. https://node.example.com" />
              <div id="advNodeStatus" class="hint"></div>
            </label>
            <label>
              <span class="lbl">Method</span>
              <select id="advMethod" class="sel"></select>
            </label>
          </div>
          <div id="advFiltersWrap" style="margin-top:10px;">
            <div style="font-size:12px; color:var(--muted); margin-bottom:6px;">Filters</div>
            <div id="advFilters" class="filters-grid"></div>
          </div>
        </div>
      </div>

      <button id="goBtn" class="bar-search-button" type="button">Go</button>
      <button id="advancedBtn" class="bar-param-button" type="button" style="width:auto; padding:0 10px;">Advanced</button>
    </div>
    
  </main>
  <footer id="siteFooter" class="site-footer" role="contentinfo" aria-label="Footer">
    <div class="foot-inner">
      <div class="foot-meta">
        <span id="feVersion">Frontend v—</span>
        <span>•</span>
        <span id="nodeVersion">Node —</span>
      </div>
      <nav class="foot-links" aria-label="Footer links">
        <a href="https://BrickerFixer.github.io/">News</a>
        <a href="/about.html">About</a>
        <a href="https://github.com/BrickerFixer/Lumen-frontend" target="_blank" rel="noopener noreferrer">Source</a>
      </nav>
    </div>
  </footer>

  <script>
    // === DEFAULT NODE CONFIGURATION ===
    const DEFAULT_NODE = "http://localhost:3001"; // ← YOUR NODE

    // Fastlane toggle
    const hdr = document.getElementById('hdr');
    const fastlaneBtn = document.getElementById('fastlaneBtn');
    const fastlane = document.getElementById('fastlane');
    let fastlaneOpen = false;
    function applyHeaderState() {
      hdr.classList.toggle('is-fastlane', fastlaneOpen);
      fastlane.classList.toggle('open', fastlaneOpen);
      fastlane.setAttribute('aria-hidden', String(!fastlaneOpen));
    }
    fastlaneBtn.addEventListener('click', () => { fastlaneOpen = !fastlaneOpen; applyHeaderState(); });
    window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && fastlaneOpen) { fastlaneOpen = false; applyHeaderState(); } });

    // Logo
    const ASSET_DIR = "resources/logo/";
    let LOGO_ASSETS = ["copycat.html","proc.html","flashlight.html","magnet.html","mondrian.html","pointilism.html","coffee.html","pipes.html","captcha.html"].map(x => ASSET_DIR + x);
    const $logo = document.getElementById("logo");
    (async function initAssets() {
      try { const res = await fetch(ASSET_DIR + "manifest.json", { cache: "no-store" });
        if (res.ok) { const json = await res.json(); if (Array.isArray(json.assets) && json.assets.length) LOGO_ASSETS = json.assets.map(x => ASSET_DIR + x); }
      } catch(_) {}
      loadRandomLogo();
    })();
    const isHTML = p => /\.html?$/i.test(p);
    const isImg = p => /\.(png|jpe?g|gif|svg|webp|avif)$/i.test(p);
    function showDefaultLogo(){ $logo.innerHTML = `<div class="logo-text" aria-label="Lumen"><span class="i">I</span><span class="rest">ndex</span></div>`; }
    async function loadRandomLogo(){ if(!LOGO_ASSETS.length) return showDefaultLogo(); await showAsset(LOGO_ASSETS[Math.floor(Math.random()*LOGO_ASSETS.length)]); }
    async function showAsset(url){ const lower=url.toLowerCase();
      if(isHTML(lower)){ $logo.innerHTML=""; const frame=document.createElement("iframe"); frame.src=url; frame.loading="eager"; frame.title="Lumen logo"; $logo.appendChild(frame); }
      else if(isImg(lower)){ $logo.innerHTML=""; const img=new Image(); img.alt="Lumen logo"; img.decoding="async"; img.src=url; $logo.appendChild(img); }
      else showDefaultLogo();
    }
    window.addEventListener("load",()=>{ const q=document.getElementById("q"); if(q) q.focus({preventScroll:true}); });

    // Homepage search + inline Advanced
    const SEARCH_PAGE = '/lumsearch.html';

    const pageUrl = new URL(window.location.href);
    const urlNodeParam = pageUrl.searchParams.get('node');
    const defaultNode = urlNodeParam !== null ? urlNodeParam : DEFAULT_NODE;

    const homeSearchForm = document.getElementById('homeSearchForm');
    const qInput = document.getElementById('q');
    const goBtn = document.getElementById('goBtn');
    const advancedBtn = document.getElementById('advancedBtn');
    const advNode = document.getElementById('advNode');
    const advNodeStatus = document.getElementById('advNodeStatus');
    const advMethod = document.getElementById('advMethod');
    const advFiltersWrap = document.getElementById('advFiltersWrap');
    const advFilters = document.getElementById('advFilters');

    // Random fun placeholder suggestions
    const placeholders = [
      "Weather in New York…",
      "What is periwinkle...",
      "Why do cats purr...",
      "Best pizza near me...",
      "How fast can a snail go...",
      "Who invented the paperclip...",
      "Time in Tokyo right now...",
      "Is cereal soup...",
      "Can fish sneeze...",
      "Quantum computing for kids...",
      "How to fold a fitted sheet...",
      "Why is the sky blue...",
      "Coffee or tea...",
      "How many stars are in the universe...",
      "What's trending today...",
      "Is AI taking over the world...",
      "Where is the tallest tree...",
      "Recipes with only 3 ingredients...",
      "Meaning of life..."
    ];

    // Assign a random one on page load
    qInput.placeholder = placeholders[Math.floor(Math.random() * placeholders.length)];


    // Pre-fill node input if we have a default and input is empty
    if (defaultNode && !advNode.value) {
      advNode.value = defaultNode;
    }

    let advOpen = false;
    let methods = [];
    let selectedMethod = '';
    let methodCapabilities = {};
    let filterValues = {};
    let metadataFetchId = 0;

    function escapeHtml(s=''){ return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'<','>':'>','"':'&quot;',"'":'&#39;'}[c])); }
    function prettifyId(id){ return id.replace(/[-_]+/g,' ').replace(/([a-z0-9])([A-Z])/g,'$1 $2').replace(/\s+/g,' ').trim().replace(/\b\w/g,c=>c.toUpperCase()); }
    function getMethodLabel(id){ const caps = methodCapabilities[id] || {}; return caps.displayName || caps.label || caps.name || caps.title || prettifyId(id); }

    function toggleAdvanced() {
      advOpen = !advOpen;
      searchAdv.classList.toggle('open', advOpen);
      searchStack.classList.toggle('adv-open', advOpen);
      advancedBtn.textContent = advOpen ? 'Hide' : 'Advanced';
      if (advOpen && !methods.length) {
        fetchMetadata();
      }
    }
    advancedBtn.addEventListener('click', toggleAdvanced);

    async function fetchMetadata() {
      const fetchId = ++metadataFetchId;
      const node = (advNode.value || '').trim() || defaultNode;
      if (!node) {
        advNodeStatus.textContent = 'Node address is required to load methods.';
        advMethod.innerHTML = '';
        advFilters.innerHTML = '';
        return;
      }

      advNodeStatus.textContent = 'Loading methods…';
      try {
        const res = await fetch(node + '/metadata', { method: 'GET' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        if (fetchId !== metadataFetchId) return;
        methods = Array.isArray(data.methods) ? data.methods : [];
        methodCapabilities = data.methodCapabilities || {};
        renderMethodSelect();
        renderFilters();
        advNodeStatus.textContent = '';
      } catch (e) {
        if (fetchId !== metadataFetchId) return;
        advNodeStatus.textContent = 'Failed to load metadata from node.';
        advMethod.innerHTML = '';
        advFilters.innerHTML = '';
      }
    }

    function renderMethodSelect() {
      const current = selectedMethod;
      advMethod.innerHTML = methods.map(m => `<option value="${escapeHtml(m)}">${escapeHtml(getMethodLabel(m))}</option>`).join('');
      if (current && methods.includes(current)) {
        advMethod.value = current;
      } else {
        selectedMethod = methods[0] || '';
        advMethod.value = selectedMethod;
      }
      advMethod.disabled = !methods.length;
    }

    function renderFilters() {
      advFilters.innerHTML = '';
      const caps = methodCapabilities[selectedMethod] || {};
      const flts = Array.isArray(caps.filters) ? caps.filters : [];
      advFiltersWrap.style.display = flts.length ? 'block' : 'none';
      flts.forEach(f => {
        const wrap = document.createElement('label');
        wrap.innerHTML = `<span class="lbl">${escapeHtml(f.name)}</span>`;
        let input;
        if (Array.isArray(f.choices)) {
          input = document.createElement('select'); input.className = 'sel';
          f.choices.forEach(choice => {
            const opt = document.createElement('option'); opt.value = choice; opt.textContent = choice; input.appendChild(opt);
          });
          input.value = (filterValues[f.name] !== undefined) ? filterValues[f.name] : (f.default ?? f.choices[0] ?? '');
        } else {
          input = document.createElement('input'); input.className = 'flt-input'; input.type = 'text';
          input.value = (filterValues[f.name] !== undefined) ? filterValues[f.name] : (f.default ?? '');
        }
        input.onchange = () => { filterValues[f.name] = input.value; };
        wrap.appendChild(input);
        advFilters.appendChild(wrap);
      });
    }

    advNode.addEventListener('change', () => { 
      methods = []; 
      methodCapabilities = {}; 
      selectedMethod = ''; 
      filterValues = {}; 
      fetchMetadata(); 
    });
    advMethod.addEventListener('change', () => { selectedMethod = advMethod.value; renderFilters(); });

    function buildSearchUrl() {
      const q = (qInput.value || '').trim();
      const node = (advNode.value || '').trim() || defaultNode;

      if (!node) {
        throw new Error('Node is required');
      }

      const url = new URL(SEARCH_PAGE, window.location.origin);
      if (q) url.searchParams.set('q', q);
      url.searchParams.set('node', node);

      const caps = methodCapabilities[selectedMethod] || {};
      const flts = Array.isArray(caps.filters) ? caps.filters : [];
      flts.forEach(f => {
        const v = (filterValues[f.name] !== undefined) ? String(filterValues[f.name]).trim() : '';
        if (v) url.searchParams.set(f.name, v);
      });
      return url.toString();
    }

    function doSearchRedirect() {
      const node = (advNode.value || '').trim() || defaultNode;
      if (!node) {
        advNodeStatus.textContent = 'Node address is required.';
        advNode.focus();
        return;
      }
      try {
        window.location.href = buildSearchUrl();
      } catch (e) {
        advNodeStatus.textContent = 'Node address is required.';
        advNode.focus();
      }
    }

    homeSearchForm.addEventListener('submit', (e) => { e.preventDefault(); doSearchRedirect(); });
    goBtn.addEventListener('click', doSearchRedirect);
  </script>
  <script>
(function() {
  const DEFAULT_NODE = "http://localhost:3001"; // ← same as above

  const feSpan = document.getElementById('feVersion');
  const nodeSpan = document.getElementById('nodeVersion');

  const feMeta = document.querySelector('meta[name="app:version"]');
  const FRONTEND_VERSION = (window.__FRONTEND_VERSION__ || (feMeta && feMeta.content) || 'dev').trim();
  feSpan.textContent = `Frontend v${FRONTEND_VERSION}`;

  function getUrlNode() {
    try {
      const u = new URL(window.location.href);
      return u.searchParams.get('node');
    } catch {
      return null;
    }
  }

  async function fetchNodeInfo(nodeBase) {
    const info = { name: '', version: '' };

    async function getJSON(url, ms = 2500) {
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort(), ms);
      try {
        const res = await fetch(url, { signal: ctrl.signal });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        return await res.json();
      } finally {
        clearTimeout(t);
      }
    }

    try {
      const meta = await getJSON(nodeBase + '/metadata');
      info.name = meta?.name || '';
      info.version = meta?.version || meta?.nodeVersion || '';
    } catch {}

    if (!info.version) {
      try {
        const health = await getJSON(nodeBase + '/health');
        info.version = health?.version || health?.nodeVersion || '';
      } catch {}
    }

    if (!info.name) {
      try { info.name = new URL(nodeBase).host; } catch { info.name = nodeBase; }
    }
    return info;
  }

  async function updateNodeFooter(nodeBase) {
    if (!nodeBase) {
      nodeSpan.textContent = 'Node: not specified';
      return;
    }
    try {
      const info = await fetchNodeInfo(nodeBase);
      const verText = info.version ? ` v${info.version}` : '';
      nodeSpan.textContent = `Node: ${info.name}${verText}`;
    } catch {
      nodeSpan.textContent = 'Node: offline';
    }
  }

  const initialNode = getUrlNode() || DEFAULT_NODE;
  updateNodeFooter(initialNode);

  const advNode = document.getElementById('advNode');
  if (advNode) {
    advNode.addEventListener('change', () => {
      const val = advNode.value.trim();
      const nextNode = val || getUrlNode() || DEFAULT_NODE;
      updateNodeFooter(nextNode);
    });
  }
})();
</script>
</body>
</html>