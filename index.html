<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lumen</title>
  <link href="resources/styles/branding.css" rel="stylesheet">
  <link href="resources/styles/homepage.css" rel="stylesheet">
  <link href="resources/styles/universal.css" rel="stylesheet">
</head>
<body>
  <header id="hdr" class="hdr" style="--hdr-h:72px">
    <div class="hdr-inner">
      <div class="bar">
        <a href="/" aria-label="Lumen home"><img class="logo-img" src="resources/service-icons/mini-mini.png" alt="Lumen"></a>
        <div style="display:flex; gap:8px;">
          <button id="fastlaneBtn" class="icon-btn" aria-label="Fastlane">
            <img class="icon" src="resources/svg/dashboard_24dp_E3E3E3_FILL0_wght400_GRAD0_opsz24.svg">
          </button>
        </div>
      </div>

      <div id="fastlane" class="fastlane" aria-hidden="true">
        
        <div class="fl-tabs">
          <button class="fl-tab active" data-tab="pinned">Pinned</button>
          <button class="fl-tab" data-tab="nodes">Nodes</button>
          <button class="fl-tab" data-tab="settings">Settings</button>
        </div>

        <div id="pinnedTab" class="fl-content active">
          <div id="pinnedGrid" class="pinned-grid"></div>
          <button class="btn" id="addPinnedBtn">+ Add Pinned Search</button>
        </div>

        <div id="nodesTab" class="fl-content">
          <div id="nodesList" class="nodes-list"></div>
          <button class="btn" id="addNodeBtn">+ Add Node</button>
          <button class="btn" id="testNodesBtn">Test Nodes (Find Fastest)</button> <!-- New Button -->
        </div>

        <div id="settingsTab" class="fl-content">
          <div class="settings-group">
            <div class="settings-group-title">Appearance</div>
            <div class="setting-row">
              <div>
                <div class="setting-label">Custom CSS Path</div>
                <div class="setting-desc">Enter URL to a custom CSS file</div>
              </div>
              <input type="text" id="customCssInput" class="custom-css-input" placeholder="e.g., https://example.com/mytheme.css">
            </div>
            <div class="setting-row">
              <div>
                <div class="setting-label">Animated Logos</div>
                <div class="setting-desc">Show animated logo variations</div>
              </div>
              <div class="toggle active" id="toggleLogos"></div> <!-- This is the toggle we'll control -->
            </div>
          </div>
          <!-- Removed Search Settings -->
        </div>
      </div>
    </div>
  </header>

  <main class="wrap">
    <div id="logo">
      <!-- Content will be dynamically set by JavaScript -->
    </div>

    <div class="search-table">
      <div class="search-stack" id="searchStack">
        <form class="search" id="homeSearchForm" autocomplete="off">
          <input class="q" id="q" name="q" type="search" placeholder="" /> <!-- Removed autofocus -->
        </form>



        <!-- Inline Advanced -->
        <div id="searchAdv" class="search-adv" aria-label="Advanced search">
          <div class="adv-grid">
            <label>
              <span class="lbl">Node</span>
              <input id="advNode" class="flt-input" placeholder="e.g. https://node.example.com  " />
              <div id="advNodeStatus" class="hint"></div>
            </label>
            <label>
              <span class="lbl">Method</span>
              <select id="advMethod" class="sel"></select>
            </label>
          </div>
          <div id="advFiltersWrap" style="margin-top:10px;">
            <div style="font-size:12px; color:var(--muted); margin-bottom:6px;">Filters</div>
            <div id="advFilters" class="filters-grid"></div>
          </div>
        </div>
      </div>

      <button id="goBtn" class="bar-search-button" type="button">Go</button>
      <button id="advancedBtn" class="bar-param-button" type="button" style="width:auto; padding:0 10px;">Advanced</button>
    </div>
            <div id="motd-container" class="motd-container"></div>
  </main>
  <footer id="siteFooter" class="site-footer" role="contentinfo" aria-label="Footer">
    <div class="foot-inner">
      <div class="foot-meta">
        <span id="feVersion">Frontend v—</span>
        <span>•</span>
        <span id="nodeVersion">Node —</span>
      </div>
      <nav class="foot-links" aria-label="Footer links">
        <a href="https://BrickerFixer.github.io/  ">News</a>
        <a href="/about.html">About</a>
        <a href="https://github.com/BrickerFixer/Lumen-frontend" target="_blank" rel="noopener noreferrer">Source</a>
      </nav>
    </div>
  </footer>
  

  <script>
    // === DEFAULT NODE CONFIGURATION ===
    const DEFAULT_NODE = "http://localhost:3001"; // ← YOUR NODE

    // Fastlane toggle
    const hdr = document.getElementById('hdr');
    const fastlaneBtn = document.getElementById('fastlaneBtn');
    const fastlane = document.getElementById('fastlane');
    let fastlaneOpen = false;
    function applyHeaderState() {
      hdr.classList.toggle('is-fastlane', fastlaneOpen);
      fastlane.classList.toggle('open', fastlaneOpen);
      fastlane.setAttribute('aria-hidden', String(!fastlaneOpen));
    }
    fastlaneBtn.addEventListener('click', () => { fastlaneOpen = !fastlaneOpen; applyHeaderState(); });
    window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && fastlaneOpen) { fastlaneOpen = false; applyHeaderState(); } });

    // --- LOGO LOGIC WITH TOGGLE INTEGRATION ---
    const ASSET_DIR = "resources/logo/";
    let LOGO_ASSETS = ["copycat.html","proc.html","flashlight.html","magnet.html","mondrian.html","pointilism.html","coffee.html","pipes.html","captcha.html","dos.html", "cocktail.html"].map(x => ASSET_DIR + x);
    const $logo = document.getElementById("logo");
    const toggleLogosElement = document.getElementById('toggleLogos'); // Get the toggle element

    // Determine initial state from localStorage or default to active
    let areLogosAnimated = localStorage.getItem('lumen_animated_logos') !== 'false'; // Default to true if not set
    if (areLogosAnimated) {
        toggleLogosElement.classList.add('active');
    } else {
        toggleLogosElement.classList.remove('active');
    }

    // Function to show the static text logo
    function showDefaultLogo(){
        $logo.innerHTML = `<div class="logo" aria-label="Lumen"><span class="i">L</span><span class="rest">umen</span></div>`;
    }

    // Function to load and show a random animated logo
    async function loadRandomLogo(){
        if(!LOGO_ASSETS.length) return showDefaultLogo();
        await showAsset(LOGO_ASSETS[Math.floor(Math.random()*LOGO_ASSETS.length)]);
    }

    // Function to show a specific asset (iframe or img)
    const isHTML = p => /\.html?$/i.test(p);
    const isImg = p => /\.(png|jpe?g|gif|svg|webp|avif)$/i.test(p);
    async function showAsset(url){
        const lower=url.toLowerCase();
        $logo.innerHTML = ""; // Clear previous content
        if(isHTML(lower)){
            const frame=document.createElement("iframe");
            frame.src=url;
            frame.loading="eager";
            frame.title="Lumen logo";
            $logo.appendChild(frame);
        } else if(isImg(lower)){
            const img=new Image();
            img.alt="Lumen logo";
            img.decoding="async";
            img.src=url;
            $logo.appendChild(img);
        } else {
            showDefaultLogo(); // Fallback to text if asset type is unknown
        }
    }

    // Initial logo display based on toggle state
    (async function initLogo() {
        try {
            // Attempt to load asset list from manifest, fallback to default list if failed
            const res = await fetch(ASSET_DIR + "manifest.json", { cache: "no-store" });
            if (res.ok) {
                const json = await res.json();
                if (Array.isArray(json.assets) && json.assets.length) {
                    LOGO_ASSETS = json.assets.map(x => ASSET_DIR + x);
                }
            }
        } catch(_) {
            // Keep default LOGO_ASSETS if manifest fails
        }

        // Show logo based on the current toggle state
        if (areLogosAnimated) {
            await loadRandomLogo();
        } else {
            showDefaultLogo();
        }
    })();

    // Event listener for the animated logos toggle
    toggleLogosElement.addEventListener('click', async () => {
        toggleLogosElement.classList.toggle('active');
        areLogosAnimated = toggleLogosElement.classList.contains('active');
        localStorage.setItem('lumen_animated_logos', areLogosAnimated); // Save state

        if (areLogosAnimated) {
            await loadRandomLogo(); // Load random logo if enabled
        } else {
            showDefaultLogo(); // Show static text if disabled
        }
    });

    // Homepage search + inline Advanced
    const SEARCH_PAGE = '/lumsearch.html';

    const pageUrl = new URL(window.location.href);
    const urlNodeParam = pageUrl.searchParams.get('node');
    // Removed defaultNode logic here, will get from state

    const homeSearchForm = document.getElementById('homeSearchForm');
    const qInput = document.getElementById('q');
    const goBtn = document.getElementById('goBtn');
    const advancedBtn = document.getElementById('advancedBtn');
    const advNode = document.getElementById('advNode');
    const advNodeStatus = document.getElementById('advNodeStatus');
    const advMethod = document.getElementById('advMethod');
    const advFiltersWrap = document.getElementById('advFiltersWrap');
    const advFilters = document.getElementById('advFilters');

    // Random fun placeholder suggestions
    const placeholders = [
      "Weather in New York…",
      "What is periwinkle...",
      "Why do cats purr...",
      "Best pizza near me...",
      "How fast can a snail go...",
      "Who invented the paperclip...",
      "Time in Tokyo right now...",
      "Is cereal soup...",
      "Can fish sneeze...",
      "Quantum computing for kids...",
      "How to fold a fitted sheet...",
      "Why is the sky blue...",
      "Coffee or tea...",
      "How many stars are in the universe...",
      "What's trending today...",
      "Is AI taking over the world...",
      "Where is the tallest tree...",
      "Recipes with only 3 ingredients...",
      "Meaning of life..."
    ];

    // Assign a random one on page load
    qInput.placeholder = placeholders[Math.floor(Math.random() * placeholders.length)];


    // --- NEW LOGIC FOR NODE SELECTION ---

    // Function to get the preferred node based on saved state
    function getPreferredNode() {
        const urlNodeParam = pageUrl.searchParams.get('node');
        if (urlNodeParam) return urlNodeParam; // Use URL param if present

        // Otherwise, try to find the first active node from the saved list
        const savedNodes = JSON.parse(localStorage.getItem('lumen_nodes') || '[]');
        const activeNode = savedNodes.find(node => node.active === true);
        if (activeNode) {
            return activeNode.url;
        }

        // Fallback to the default if no saved active node
        return DEFAULT_NODE;
    }

    // Pre-fill node input with the preferred node
    const preferredNode = getPreferredNode();
    if (!advNode.value) { // Only set if empty
        advNode.value = preferredNode;
    }


    let advOpen = false;
    let methods = [];
    let selectedMethod = '';
    let methodCapabilities = {};
    let filterValues = {};
    let metadataFetchId = 0;

    function escapeHtml(s=''){ return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'<','>':'>','"':'&quot;',"'":'&#39;'}[c])); }
    function prettifyId(id){ return id.replace(/[-_]+/g,' ').replace(/([a-z0-9])([A-Z])/g,'$1 $2').replace(/\s+/g,' ').trim().replace(/\b\w/g,c=>c.toUpperCase()); }
    function getMethodLabel(id){ const caps = methodCapabilities[id] || {}; return caps.displayName || caps.label || caps.name || caps.title || prettifyId(id); }

    function toggleAdvanced() {
      advOpen = !advOpen;
      searchAdv.classList.toggle('open', advOpen);
      searchStack.classList.toggle('adv-open', advOpen);
      advancedBtn.textContent = advOpen ? 'Hide' : 'Advanced';
      if (advOpen && !methods.length) {
        fetchMetadata();
      }
    }
    advancedBtn.addEventListener('click', toggleAdvanced);

    async function fetchMetadata() {
      const fetchId = ++metadataFetchId;
      const node = (advNode.value || '').trim();
      // Removed fallback to defaultNode inside fetchMetadata, rely on state or input
      if (!node) {
        advNodeStatus.textContent = 'Node address is required to load methods.';
        advMethod.innerHTML = '';
        advFilters.innerHTML = '';
        return;
      }

      advNodeStatus.textContent = 'Loading methods…';
      try {
        const res = await fetch(node + '/metadata', { method: 'GET' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        if (fetchId !== metadataFetchId) return;
        methods = Array.isArray(data.methods) ? data.methods : [];
        methodCapabilities = data.methodCapabilities || {};
        renderMethodSelect();
        renderFilters();
        advNodeStatus.textContent = '';
      } catch (e) {
        if (fetchId !== metadataFetchId) return;
        advNodeStatus.textContent = 'Failed to load metadata from node.';
        advMethod.innerHTML = '';
        advFilters.innerHTML = '';
      }
    }

    function renderMethodSelect() {
      const current = selectedMethod;
      advMethod.innerHTML = methods.map(m => `<option value="${escapeHtml(m)}">${escapeHtml(getMethodLabel(m))}</option>`).join('');
      if (current && methods.includes(current)) {
        advMethod.value = current;
      } else {
        selectedMethod = methods[0] || '';
        advMethod.value = selectedMethod;
      }
      advMethod.disabled = !methods.length;
    }

    function renderFilters() {
      advFilters.innerHTML = '';
      const caps = methodCapabilities[selectedMethod] || {};
      const flts = Array.isArray(caps.filters) ? caps.filters : [];
      advFiltersWrap.style.display = flts.length ? 'block' : 'none';
      flts.forEach(f => {
        const wrap = document.createElement('label');
        wrap.innerHTML = `<span class="lbl">${escapeHtml(f.name)}</span>`;
        let input;
        if (Array.isArray(f.choices)) {
          input = document.createElement('select'); input.className = 'sel';
          f.choices.forEach(choice => {
            const opt = document.createElement('option'); opt.value = choice; opt.textContent = choice; input.appendChild(opt);
          });
          input.value = (filterValues[f.name] !== undefined) ? filterValues[f.name] : (f.default ?? f.choices[0] ?? '');
        } else {
          input = document.createElement('input'); input.className = 'flt-input'; input.type = 'text';
          input.value = (filterValues[f.name] !== undefined) ? filterValues[f.name] : (f.default ?? '');
        }
        input.onchange = () => { filterValues[f.name] = input.value; };
        wrap.appendChild(input);
        advFilters.appendChild(wrap);
      });
    }

    advNode.addEventListener('change', () => { 
      methods = []; 
      methodCapabilities = {}; 
      selectedMethod = ''; 
      filterValues = {}; 
      fetchMetadata(); 
    });
    advMethod.addEventListener('change', () => { selectedMethod = advMethod.value; renderFilters(); });

    function buildSearchUrl() {
      const q = (qInput.value || '').trim();
      const node = (advNode.value || '').trim(); // Removed fallback to defaultNode

      if (!node) {
        throw new Error('Node is required');
      }

      const url = new URL(SEARCH_PAGE, window.location.origin);
      if (q) url.searchParams.set('q', q);
      url.searchParams.set('node', node);

      const caps = methodCapabilities[selectedMethod] || {};
      const flts = Array.isArray(caps.filters) ? caps.filters : [];
      flts.forEach(f => {
        const v = (filterValues[f.name] !== undefined) ? String(filterValues[f.name]).trim() : '';
        if (v) url.searchParams.set(f.name, v);
      });
      return url.toString();
    }

    function doSearchRedirect() {
      const node = (advNode.value || '').trim(); // Removed fallback to defaultNode
      if (!node) {
        advNodeStatus.textContent = 'Node address is required.';
        advNode.focus();
        return;
      }
      try {
        window.location.href = buildSearchUrl();
      } catch (e) {
        advNodeStatus.textContent = 'Node address is required.';
        advNode.focus();
      }
    }

    homeSearchForm.addEventListener('submit', (e) => { e.preventDefault(); doSearchRedirect(); });
    goBtn.addEventListener('click', doSearchRedirect);
  </script>
  <script>
(function() {
  const DEFAULT_NODE = "http://localhost:3001"; // ← same as above

  const feSpan = document.getElementById('feVersion');
  const nodeSpan = document.getElementById('nodeVersion');

  const feMeta = document.querySelector('meta[name="app:version"]');
  const FRONTEND_VERSION = (window.__FRONTEND_VERSION__ || (feMeta && feMeta.content) || 'dev').trim();
  feSpan.textContent = `Frontend v${FRONTEND_VERSION}`;

  function getUrlNode() {
    try {
      const u = new URL(window.location.href);
      return u.searchParams.get('node');
    } catch {
      return null;
    }
  }

  async function fetchNodeInfo(nodeBase) {
    const info = { name: '', version: '' };

    async function getJSON(url, ms = 2500) {
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort(), ms);
      try {
        const res = await fetch(url, { signal: ctrl.signal });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        return await res.json();
      } finally {
        clearTimeout(t);
      }
    }

    try {
      const meta = await getJSON(nodeBase + '/metadata');
      info.name = meta?.name || '';
      info.version = meta?.version || meta?.nodeVersion || '';
    } catch {}

    if (!info.version) {
      try {
        const health = await getJSON(nodeBase + '/health');
        info.version = health?.version || health?.nodeVersion || '';
      } catch {}
    }

    if (!info.name) {
      try { info.name = new URL(nodeBase).host; } catch { info.name = nodeBase; }
    }
    return info;
  }

  async function updateNodeFooter(nodeBase) {
    if (!nodeBase) {
      nodeSpan.textContent = 'Node: not specified';
      return;
    }
    try {
      const info = await fetchNodeInfo(nodeBase);
      const verText = info.version ? ` v${info.version}` : '';
      nodeSpan.textContent = `Node: ${info.name}${verText}`;
    } catch {
      nodeSpan.textContent = 'Node: offline';
    }
  }

  // Use the same logic as the main script to determine the initial node
  const initialNode = getUrlNode() || getPreferredNode(); // Use getPreferredNode defined in main script scope
  updateNodeFooter(initialNode);

  const advNode = document.getElementById('advNode');
  if (advNode) {
    advNode.addEventListener('change', () => {
      const val = advNode.value.trim();
      const nextNode = val || getUrlNode() || getPreferredNode(); // Use getPreferredNode again
      updateNodeFooter(nextNode);
    });
  }
})();
</script>
  <script>
    const state = {
      pinned: JSON.parse(localStorage.getItem('lumen_pinned') || '[]'),
      nodes: JSON.parse(localStorage.getItem('lumen_nodes') || `[{"url":"${DEFAULT_NODE}","active":true}]`) // Initialize with default active
    };

    function save() {
      localStorage.setItem('lumen_pinned', JSON.stringify(state.pinned));
      localStorage.setItem('lumen_nodes', JSON.stringify(state.nodes));
    }

    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && fastlaneOpen) {
        fastlaneOpen = false;
        fastlane.classList.remove('open');
        hdr.classList.remove('is-fastlane');
        fastlane.setAttribute('aria-hidden', 'true');
      }
    });

    document.querySelectorAll('.fl-tab').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.fl-tab').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.fl-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById(btn.dataset.tab + 'Tab').classList.add('active');
      });
    });

    function renderPinned() {
      const grid = document.getElementById('pinnedGrid');
      if (state.pinned.length === 0) {
        grid.innerHTML = '<div class="empty-state"><div class="empty-icon">📌</div><div>No pinned searches yet</div></div>';
        return;
      }
      grid.innerHTML = state.pinned.map((pin, i) => `
        <div class="pinned-card" onclick="window.location.href='/lumsearch.html?q=${encodeURIComponent(pin.query)}&node=${encodeURIComponent(pin.node)}'">
          <button class="pinned-card-remove" onclick="event.stopPropagation(); removePinned(${i})">×</button>
          <div class="pinned-card-title">${escapeHtml(pin.title || pin.query)}</div>
          <div class="pinned-card-query">${escapeHtml(pin.query)}</div>
          <div class="pinned-card-meta">Pinned ${new Date(pin.date).toLocaleDateString()}</div>
        </div>
      `).join('');
    }

    function renderNodes() {
      const list = document.getElementById('nodesList');
      if (state.nodes.length === 0) {
        list.innerHTML = '<div class="empty-state"><div class="empty-icon">🔌</div><div>No nodes configured</div></div>';
        return;
      }
      list.innerHTML = state.nodes.map((node, i) => `
        <div class="node-item">
          <div style="flex:1; min-width:0">
            <div class="node-url">${escapeHtml(node.url)}</div>
            <div class="node-status">
              <div class="status-dot ${node.active ? '' : 'offline'}"></div>
              ${node.active ? 'Active' : 'Inactive'}
            </div>
          </div>
          <button class="node-set-default" onclick="setNodeAsDefault(${i})">Set Default</button>
          <button class="node-remove" onclick="removeNode(${i})">Remove</button>
        </div>
      `).join('');
    }

    function escapeHtml(s) {
      const div = document.createElement('div');
      div.textContent = s;
      return div.innerHTML;
    }

    window.removePinned = (i) => {
      state.pinned.splice(i, 1);
      save();
      renderPinned();
    };

    window.removeNode = (i) => {
      if (state.nodes.length === 1) {
        alert('You must have at least one node');
        return;
      }
      state.nodes.splice(i, 1);
      save();
      renderNodes();
    };

    // New function to set a node as the default/active one
    window.setNodeAsDefault = (i) => {
        if (i < 0 || i >= state.nodes.length) return;
        // Deactivate all nodes
        state.nodes.forEach(node => node.active = false);
        // Activate the selected node
        state.nodes[i].active = true;
        save();
        renderNodes();
        // Update the main form's node input if it's empty or currently showing the old default
        if (!advNode.value || advNode.value === getPreferredNode()) {
             advNode.value = state.nodes[i].url;
        }
        updateNodeFooter(state.nodes[i].url); // Update footer immediately
    };

    document.getElementById('addPinnedBtn').addEventListener('click', () => {
      const query = prompt('Enter search query:');
      if (query && query.trim()) {
        state.pinned.push({
          query: query.trim(),
          title: query.trim(),
          node: getPreferredNode(), // Use the current preferred node
          date: Date.now()
        });
        save();
        renderPinned();
      }
    });

    document.getElementById('addNodeBtn').addEventListener('click', () => {
      const url = prompt('Enter node URL:');
      if (url && url.trim()) {
        // Check if node already exists
        if (state.nodes.some(node => node.url === url.trim())) {
            alert('Node already exists.');
            return;
        }
        // Add new node as inactive if others exist, or active if it's the first
        state.nodes.push({ url: url.trim(), active: state.nodes.length === 0 });
        save();
        renderNodes();
      }
    });

    // --- NEW: Function to test nodes for speed ---
    document.getElementById('testNodesBtn').addEventListener('click', async () => {
        if (state.nodes.length === 0) {
            alert('No nodes to test.');
            return;
        }

        const results = [];
        const testUrl = '/health'; // Use health endpoint for speed test
        const timeout = 5000; // 5 seconds timeout

        // Disable buttons during test to prevent multiple clicks
        const testBtn = document.getElementById('testNodesBtn');
        testBtn.disabled = true;
        testBtn.textContent = 'Testing...';

        try {
            for (const node of state.nodes) {
                const url = node.url + testUrl;
                const startTime = performance.now();

                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), timeout);

                    const response = await fetch(url, {
                        method: 'GET',
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);
                    const endTime = performance.now();
                    const responseTime = endTime - startTime;

                    if (response.ok) {
                        results.push({ url: node.url, responseTime, success: true });
                    } else {
                        results.push({ url: node.url, responseTime, success: false, status: response.status });
                    }
                } catch (error) {
                    const endTime = performance.now();
                    const responseTime = endTime - startTime;
                    results.push({ url: node.url, responseTime, success: false, error: error.message });
                }
            }

            // Sort results by response time (fastest first)
            results.sort((a, b) => a.responseTime - b.responseTime);

            // Find the fastest successful node
            const fastestNode = results.find(r => r.success);

            if (fastestNode) {
                alert(`Fastest responding node: ${fastestNode.url}\nResponse time: ${fastestNode.responseTime.toFixed(2)}ms\n\nSetting this as the default node.`);
                setNodeAsDefault(state.nodes.findIndex(n => n.url === fastestNode.url));
            } else {
                alert('No nodes responded successfully or within the timeout period.');
                console.error('Node speed test results:', results);
            }

        } finally {
            // Re-enable button
            testBtn.disabled = false;
            testBtn.textContent = 'Test Nodes (Find Fastest)';
        }
    });

    // Handle toggle clicks for Animated Logos (only toggle)
    // Removed general toggle listener, handled specifically for logos above

    document.getElementById('goBtn').addEventListener('click', () => {
      const q = document.getElementById('q').value.trim();
      const node = (document.getElementById('advNode').value || '').trim(); // Use value from input field
      if (q && node) { // Check if node is provided
        window.location.href = `/lumsearch.html?q=${encodeURIComponent(q)}&node=${encodeURIComponent(node)}`;
      } else if (!node) {
          document.getElementById('advNodeStatus').textContent = 'Node address is required.';
          document.getElementById('advNode').focus();
      }
    });

    renderPinned();
    renderNodes();

    // --- NEW: Custom CSS Handling ---
    const customCssLink = document.createElement('link');
    customCssLink.rel = 'stylesheet';
    customCssLink.id = 'custom-theme-css';
    document.head.appendChild(customCssLink);

    const customCssInput = document.getElementById('customCssInput');
    const savedCustomCssUrl = localStorage.getItem('lumen_custom_css_url') || '';
    customCssInput.value = savedCustomCssUrl;

    if (savedCustomCssUrl) {
        customCssLink.href = savedCustomCssUrl;
    }

    customCssInput.addEventListener('change', () => {
        const newUrl = customCssInput.value.trim();
        if (newUrl) {
            customCssLink.href = newUrl;
            localStorage.setItem('lumen_custom_css_url', newUrl);
        } else {
            customCssLink.href = ''; // Remove link if input is empty
            localStorage.removeItem('lumen_custom_css_url');
        }
    });

    // Ensure the main form uses the preferred node initially if input is empty
    // This handles the case where the page loads without an explicit node param
    if (!advNode.value) {
        advNode.value = getPreferredNode();
    }

  </script>
    <script>
    (function() {
      // This IIFE (Immediately Invoked Function Expression) keeps the scope clean.
      document.addEventListener('DOMContentLoaded', () => {
        const motdContainer = document.getElementById('motd-container');
        if (!motdContainer) return;

        // Use the same logic as other scripts to determine the current node.
        const pageUrl = new URL(window.location.href);
        const urlNodeParam = pageUrl.searchParams.get('node');
        // Use the getPreferredNode function from the main script scope
        const currentNode = urlNodeParam || getPreferredNode(); // Use the function defined in main script scope

        async function fetchAndRenderMOTD() {
          try {
            const response = await fetch(`${currentNode}/motd`);
            if (!response.ok) {
              throw new Error(`MOTD endpoint failed with status ${response.status}`);
            }

            const data = await response.json();

            // Don't render anything if there's no message content.
            if (!data.header && !data.subtitle) {
              return;
            }

            // Create the main banner element. If there's a link, it's an <a> tag.
            const isClickable = !!data.header_link;
            const banner = document.createElement('div');
            banner.className = 'motd-banner';


            // 1. Create and add the Image (if it exists)
            if (data.image) {
              const imageUrl = new URL(data.image, currentNode).href;
              const img = document.createElement('img');
              img.src = imageUrl;
              img.alt = data.header || 'MOTD Image';
              img.className = 'motd-image';
              banner.appendChild(img);
            }

            // 2. Create the content container for text
            const contentDiv = document.createElement('div');
            contentDiv.className = 'motd-content';

            // 3. Create and add the Header (if it exists)
            if (data.header) {
              const headerDiv = document.createElement(isClickable ? 'a' : 'div');
              headerDiv.className = 'motd-header';
              headerDiv.textContent = data.header;
              contentDiv.appendChild(headerDiv);
              if (isClickable) {
                headerDiv.classList.add('is-clickable');
                headerDiv.href = data.header_link;
                headerDiv.target = '_blank'; // Open in a new tab
                headerDiv.rel = 'noopener noreferrer';
              }
            }

            // 4. Create and add the Subtitle (if it exists)
            if (data.subtitle) {
              const subtitleDiv = document.createElement('div');
              subtitleDiv.className = 'motd-subtitle';
              subtitleDiv.textContent = data.subtitle;
              contentDiv.appendChild(subtitleDiv);
            }
            
            banner.appendChild(contentDiv);
            
            // Clear the container and inject the new banner
            motdContainer.innerHTML = '';
            motdContainer.appendChild(banner);

          } catch (error) {
            console.error('Could not fetch or render MOTD:', error);
            // Do nothing on the UI, the banner will simply not appear.
          }
        }

        fetchAndRenderMOTD();
      });
    })();
  </script>
</body>
</html>